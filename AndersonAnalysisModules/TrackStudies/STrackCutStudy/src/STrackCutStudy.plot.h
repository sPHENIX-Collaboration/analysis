// ----------------------------------------------------------------------------
// 'STrackCutStudy.plot.h'
// Derek Anderson
// 03.14.2022
//
// Reads in the 'ntp_track' Ntuple
// generated by the SVtxEvaluator
// class and studies the impact
// of cutting on various quantities.
// ----------------------------------------------------------------------------

#pragma once

using namespace std;



// plot methods ---------------------------------------------------------------

void STrackCutStudy::MakeCutText() {

  // cut labels
  const TString sPrimary("Is primary");
  const TString sMVtxCut("MVTX hits = (");
  const TString sNTpcCut("TPC hits = (");
  const TString sVzCut("z-vertex = (");
  const TString sDcaXyCut("DCA (XY) = (");
  const TString sDcaZCut("DCA (Z) = (");
  const TString sQualityCut("Quality = (");
  const TString sVzUnits("cm");
  const TString sDcaUnits("#mum");

  // make text
  TString sMVtxTxt     = sMVtxCut;
  TString sNTpcTxt     = sNTpcCut;
  TString sVzTxt       = sVzCut;
  TString sDcaXyTxt    = sDcaXyCut;
  TString sDcaZTxt     = sDcaZCut;
  TString sQualityTxt  = sQualityCut;
  sMVtxTxt            += nMVtxCut.first;
  sNTpcTxt            += nTpcCut.first;
  sVzTxt              += vzCut.first;
  sDcaXyTxt           += dcaXyCut.first;
  sDcaZTxt            += dcaZCut.first;
  sQualityTxt         += qualityCut.first;
  sMVtxTxt            += ", ";
  sNTpcTxt            += ", ";
  sVzTxt              += ", ";
  sDcaXyTxt           += ", ";
  sDcaZTxt            += ", ";
  sQualityTxt         += ", ";
  sMVtxTxt            += nMVtxCut.second;
  sNTpcTxt            += nTpcCut.second;
  sVzTxt              += vzCut.second;
  sDcaXyTxt           += dcaXyCut.second;
  sDcaZTxt            += dcaZCut.second;
  sQualityTxt         += qualityCut.second;
  sMVtxTxt            += ")";
  sNTpcTxt            += ")";
  sVzTxt              += ") ";
  sDcaXyTxt           += ") ";
  sDcaZTxt            += ") ";
  sQualityTxt         += ")";
  sVzTxt              += sVzUnits.Data();
  sDcaXyTxt           += sDcaUnits.Data();
  sDcaZTxt            += sDcaUnits.Data();

  // determine how many lines to add
  UInt_t nCut(0);
  if (doPrimaryCut) nCut++;
  if (doMVtxCut)    nCut++;
  if (doTpcCut)     nCut++;
  if (doVzCut)      nCut++;
  if (doDcaXyCut)   nCut++;
  if (doDcaZCut)    nCut++;
  if (doQualityCut) nCut++;

  // make text box
  const UInt_t  fTxtC       = 42;
  const UInt_t  fAlnC       = 12;
  const UInt_t  fColC       = 0;
  const UInt_t  fLinC       = 1;
  const UInt_t  fFilC       = 0;
  const Float_t hCut        = 0.05 * nCut;
  const Float_t yCut        = 0.1 + hCut;
  const Float_t xyCut[NVtx] = {0.5, 0.1, 0.7, yCut};

  ptCut = new TPaveText(xyCut[0], xyCut[1], xyCut[2], xyCut[3], "NDC NB");
  ptCut -> SetFillColor(fColC);
  ptCut -> SetFillStyle(fFilC);
  ptCut -> SetLineColor(fColC);
  ptCut -> SetLineStyle(fLinC);
  ptCut -> SetTextFont(fTxtC);
  ptCut -> SetTextAlign(fAlnC);
  if (doPrimaryCut) ptCut -> AddText(sPrimary.Data());
  if (doMVtxCut)    ptCut -> AddText(sMVtxTxt.Data());
  if (doTpcCut)     ptCut -> AddText(sNTpcTxt.Data());
  if (doVzCut)      ptCut -> AddText(sVzTxt.Data());
  if (doDcaXyCut)   ptCut -> AddText(sDcaXyTxt.Data());
  if (doDcaZCut)    ptCut -> AddText(sDcaZTxt.Data());
  if (doQualityCut) ptCut -> AddText(sQualityTxt.Data());

  cout << "    Made text box for cuts." << endl;
  return;

}  // end 'MakeCutText()'



void STrackCutStudy::ConstructPlots(const Ssiz_t nToDraw, const Int_t typesToDraw[], const TString sDirToSaveTo, const TString sPlotLabel) {

  // check if saving directory is made, if so, recurse into it
  Bool_t dirIsThere = fOut -> cd(sDirToSaveTo.Data());
  if (!dirIsThere) {
    fOut -> mkdir(sDirToSaveTo.Data());
    fOut -> cd(sDirToSaveTo.Data());
  }

  // construct legend
  const UInt_t  fTxtL       = 42;
  const UInt_t  fColL       = 0;
  const UInt_t  fLinL       = 1;
  const UInt_t  fFilL       = 0;
  const Float_t hLeg        = 0.05 * nToDraw;
  const Float_t yLeg        = 0.1 + hLeg;
  const Float_t xyLeg[NVtx] = {0.1, 0.1, 0.3, yLeg};

  TLegend *leg = new TLegend(xyLeg[0], xyLeg[1], xyLeg[2], xyLeg[3]);
  leg -> SetFillColor(fColL);
  leg -> SetFillStyle(fFilL);
  leg -> SetLineColor(fColL);
  leg -> SetLineStyle(fLinL);
  leg -> SetTextFont(fTxtL);
  for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
    leg -> AddEntry(hTrkVar[typesToDraw[iToDraw]][0], sTrkLabels[typesToDraw[iToDraw]].Data(), "pf");
  }

  // determine what to text to add to box
  Ssiz_t nTxt(0);
  Bool_t hasPileup(false);
  for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
    if (isPileup[typesToDraw[iToDraw]]) {
      hasPileup = true;
      break;
    }
  }

  if (hasPileup) {
    nTxt = nTxtPU;
  } else {
    nTxt = nTxtEO;
  }

  // construct text box
  const UInt_t  fTxtT       = 42;
  const UInt_t  fAlnT       = 12;
  const UInt_t  fColT       = 0;
  const UInt_t  fLinT       = 1;
  const UInt_t  fFilT       = 0;
  const Float_t hTxt        = 0.05 * nTxt;
  const Float_t yTxt        = 0.1 + hTxt;
  const Float_t xyTxt[NVtx] = {0.3, 0.1, 0.5, yTxt};

  TPaveText *ptTxt = new TPaveText(xyTxt[0], xyTxt[1], xyTxt[2], xyTxt[3], "NDC NB");
  ptTxt -> SetFillColor(fColT);
  ptTxt -> SetFillStyle(fFilT);
  ptTxt -> SetLineColor(fColT);
  ptTxt -> SetLineStyle(fLinT);
  ptTxt -> SetTextFont(fTxtT);
  ptTxt -> SetTextAlign(fAlnT);
  for (Ssiz_t iTxt = 0; iTxt < nTxt; iTxt++) {
    if (hasPileup) {
      ptTxt -> AddText(sTxtPU[iTxt].Data());
    } else {
      ptTxt -> AddText(sTxtEO[iTxt].Data());
    }
  }

  // construct plots
  const UInt_t  fWidth1P(750);
  const UInt_t  fWidth2P(1500);
  const UInt_t  fHeight1P(750);
  const UInt_t  fHeight2P(750);
  const UInt_t  fMode(0);
  const UInt_t  fBord(2);
  const UInt_t  fGrid(0);
  const UInt_t  fTick(1);
  const UInt_t  fLogX(0);
  const UInt_t  fLogY(0);
  const UInt_t  fLogZ(1);
  const UInt_t  fFrame(0);
  const Float_t fMarginL(0.12);
  const Float_t fMarginR1(0.02);
  const Float_t fMarginR2(0.12);
  const Float_t fMarginT(0.02);
  const Float_t fMarginB(0.12);
  const Float_t padXY[NPanel][NVtx]        = {{0., 0., 0.5, 1.}, {0.5, 0., 1., 1.}};
  const TString sOneVsTwoDimPanels[NPanel] = {"pOneDim", "pTwoDim"};

  // form canvas names
  const TString sDiffSuffix("Diff");
  const TString sFracSuffix("Frac");
  const TString sVsNTpcSuffix("VsNTpc");
  const TString sVsDcaXySuffix("VsDcaXY");
  const TString sVsDcaZSuffix("VsDcaZ");
  const TString sVsPtRecoSuffix("VsPtReco");
  const TString sVsPtTrueSuffix("VsPtTrue");
  const TString sVsPtFracSuffix("VsPtFrac");

  // for track-variable canvas names
  TString sTrkVar[NTrkVar];
  TString sTrkVarDiff[NTrkVar];
  TString sTrkVarFrac[NTrkVar];
  TString sTrkVarVsNTpc[NTrkVar];
  TString sTrkVarVsDcaXY[NTrkVar];
  TString sTrkVarVsDcaZ[NTrkVar];
  TString sTrkVarVsPtReco[NTrkVar];
  TString sTrkVarVsPtTrue[NTrkVar];
  TString sTrkVarVsPtFrac[NTrkVar];

  // for physics-variable canvas names
  TString sPhysVar[NPhysVar];
  TString sPhysVarDiff[NPhysVar];
  TString sPhysVarFrac[NPhysVar];
  TString sPhysVarVsNTpc[NPhysVar];
  TString sPhysVarVsDcaXY[NPhysVar];
  TString sPhysVarVsDcaZ[NPhysVar];
  TString sPhysVarVsPtReco[NPhysVar];
  TString sPhysVarVsPtTrue[NPhysVar];
  TString sPhysVarVsPtFrac[NPhysVar];

  // construct variable prefixes
  TString sTrkVarName[NTrkVar];
  TString sPhysVarName[NPhysVar];
  for (size_t iTrkVar = 0; iTrkVar < NTrkVar; iTrkVar++) {
    sTrkVarName[iTrkVar] = "c";
    sTrkVarName[iTrkVar].Append(sTrkVars[iTrkVar].Data());
  }
  for (size_t iPhysVar = 0; iPhysVar < NPhysVar; iPhysVar++) {
    sPhysVarName[iPhysVar] = "c";
    sPhysVarName[iPhysVar].Append(sPhysVars[iPhysVar].Data());
  }

  for (size_t iTrkVar = 0; iTrkVar < NTrkVar; iTrkVar++) {
    sTrkVar[iTrkVar]         = sTrkVarName[iTrkVar].Data();
    sTrkVarDiff[iTrkVar]     = sTrkVarName[iTrkVar].Data();
    sTrkVarFrac[iTrkVar]     = sTrkVarName[iTrkVar].Data();
    sTrkVarVsNTpc[iTrkVar]   = sTrkVarName[iTrkVar].Data();
    sTrkVarVsDcaXY[iTrkVar]  = sTrkVarName[iTrkVar].Data();
    sTrkVarVsDcaZ[iTrkVar]   = sTrkVarName[iTrkVar].Data();
    sTrkVarVsPtReco[iTrkVar] = sTrkVarName[iTrkVar].Data();
    sTrkVarVsPtTrue[iTrkVar] = sTrkVarName[iTrkVar].Data();
    sTrkVarVsPtFrac[iTrkVar] = sTrkVarName[iTrkVar].Data();
    sTrkVarDiff[iTrkVar].Append(sDiffSuffix.Data());
    sTrkVarFrac[iTrkVar].Append(sFracSuffix.Data());
    sTrkVarVsNTpc[iTrkVar].Append(sVsNTpcSuffix.Data());
    sTrkVarVsDcaXY[iTrkVar].Append(sVsDcaXySuffix.Data());
    sTrkVarVsDcaZ[iTrkVar].Append(sVsDcaZSuffix.Data());
    sTrkVarVsPtReco[iTrkVar].Append(sVsPtRecoSuffix.Data());
    sTrkVarVsPtTrue[iTrkVar].Append(sVsPtTrueSuffix.Data());
    sTrkVarVsPtFrac[iTrkVar].Append(sVsPtFracSuffix.Data());
    sTrkVar[iTrkVar].Append("_");
    sTrkVarDiff[iTrkVar].Append("_");
    sTrkVarFrac[iTrkVar].Append("_");
    sTrkVarVsNTpc[iTrkVar].Append("_");
    sTrkVarVsDcaXY[iTrkVar].Append("_");
    sTrkVarVsDcaZ[iTrkVar].Append("_");
    sTrkVarVsPtReco[iTrkVar].Append("_");
    sTrkVarVsPtTrue[iTrkVar].Append("_");
    sTrkVarVsPtFrac[iTrkVar].Append("_");
    sTrkVar[iTrkVar].Append(sPlotLabel.Data());
    sTrkVarDiff[iTrkVar].Append(sPlotLabel.Data());
    sTrkVarFrac[iTrkVar].Append(sPlotLabel.Data());
    sTrkVarVsNTpc[iTrkVar].Append(sPlotLabel.Data());
    sTrkVarVsDcaXY[iTrkVar].Append(sPlotLabel.Data());
    sTrkVarVsDcaZ[iTrkVar].Append(sPlotLabel.Data());
    sTrkVarVsPtReco[iTrkVar].Append(sPlotLabel.Data());
    sTrkVarVsPtTrue[iTrkVar].Append(sPlotLabel.Data());
    sTrkVarVsPtFrac[iTrkVar].Append(sPlotLabel.Data());
  }
  for (size_t iPhysVar = 0; iPhysVar < NPhysVar; iPhysVar++) {
    sPhysVar[iPhysVar]         = sPhysVarName[iPhysVar].Data();
    sPhysVarDiff[iPhysVar]     = sPhysVarName[iPhysVar].Data();
    sPhysVarFrac[iPhysVar]     = sPhysVarName[iPhysVar].Data();
    sPhysVarVsNTpc[iPhysVar]   = sPhysVarName[iPhysVar].Data();
    sPhysVarVsDcaXY[iPhysVar]  = sPhysVarName[iPhysVar].Data();
    sPhysVarVsDcaZ[iPhysVar]   = sPhysVarName[iPhysVar].Data();
    sPhysVarVsPtReco[iPhysVar] = sPhysVarName[iPhysVar].Data();
    sPhysVarVsPtTrue[iPhysVar] = sPhysVarName[iPhysVar].Data();
    sPhysVarVsPtFrac[iPhysVar] = sPhysVarName[iPhysVar].Data();
    sPhysVarDiff[iPhysVar].Append(sDiffSuffix.Data());
    sPhysVarFrac[iPhysVar].Append(sFracSuffix.Data());
    sPhysVarVsNTpc[iPhysVar].Append(sVsNTpcSuffix.Data());
    sPhysVarVsDcaXY[iPhysVar].Append(sVsDcaXySuffix.Data());
    sPhysVarVsDcaZ[iPhysVar].Append(sVsDcaZSuffix.Data());
    sPhysVarVsPtReco[iPhysVar].Append(sVsPtRecoSuffix.Data());
    sPhysVarVsPtTrue[iPhysVar].Append(sVsPtTrueSuffix.Data());
    sPhysVarVsPtFrac[iPhysVar].Append(sVsPtFracSuffix.Data());
    sPhysVar[iPhysVar].Append("_");
    sPhysVarDiff[iPhysVar].Append("_");
    sPhysVarFrac[iPhysVar].Append("_");
    sPhysVarVsNTpc[iPhysVar].Append("_");
    sPhysVarVsDcaXY[iPhysVar].Append("_");
    sPhysVarVsDcaZ[iPhysVar].Append("_");
    sPhysVarVsPtReco[iPhysVar].Append("_");
    sPhysVarVsPtTrue[iPhysVar].Append("_");
    sPhysVarVsPtFrac[iPhysVar].Append("_");
    sPhysVar[iPhysVar].Append(sPlotLabel.Data());
    sPhysVarDiff[iPhysVar].Append(sPlotLabel.Data());
    sPhysVarFrac[iPhysVar].Append(sPlotLabel.Data());
    sPhysVarVsNTpc[iPhysVar].Append(sPlotLabel.Data());
    sPhysVarVsDcaXY[iPhysVar].Append(sPlotLabel.Data());
    sPhysVarVsDcaZ[iPhysVar].Append(sPlotLabel.Data());
    sPhysVarVsPtReco[iPhysVar].Append(sPlotLabel.Data());
    sPhysVarVsPtTrue[iPhysVar].Append(sPlotLabel.Data());
    sPhysVarVsPtFrac[iPhysVar].Append(sPlotLabel.Data());
  }

  // for track-variable plots
  TCanvas *cTrkVar[NTrkVar];
  TCanvas *cTrkVarDiff[NTrkVar];
  TCanvas *cTrkVarFrac[NTrkVar];
  TCanvas *cTrkVarVsNTpc[NTrkVar];
  TCanvas *cTrkVarVsDcaXY[NTrkVar];
  TCanvas *cTrkVarVsDcaZ[NTrkVar];
  TCanvas *cTrkVarVsPtReco[NTrkVar];
  TCanvas *cTrkVarVsPtTrue[NTrkVar];
  TCanvas *cTrkVarVsPtFrac[NTrkVar];
  TPad    *pTrkVarVsNTpc[NTrkVar][NPanel];
  TPad    *pTrkVarVsDcaXY[NTrkVar][NPanel];
  TPad    *pTrkVarVsDcaZ[NTrkVar][NPanel];
  TPad    *pTrkVarVsPtReco[NTrkVar][NPanel];
  TPad    *pTrkVarVsPtTrue[NTrkVar][NPanel];
  TPad    *pTrkVarVsPtFrac[NTrkVar][NPanel];
  for (size_t iTrkVar = 0; iTrkVar < NTrkVar; iTrkVar++) {

    // 1d track variable
    cTrkVar[iTrkVar] = new TCanvas(sTrkVar[iTrkVar].Data(), "", fWidth1P, fHeight1P);
    cTrkVar[iTrkVar] -> SetGrid(fGrid, fGrid);
    cTrkVar[iTrkVar] -> SetTicks(fTick, fTick);
    cTrkVar[iTrkVar] -> SetLogx(fLogX);
    cTrkVar[iTrkVar] -> SetLogy(fLogY);
    cTrkVar[iTrkVar] -> SetLogz(fLogZ);
    cTrkVar[iTrkVar] -> SetBorderMode(fMode);
    cTrkVar[iTrkVar] -> SetBorderSize(fBord);
    cTrkVar[iTrkVar] -> SetFrameBorderMode(fFrame);
    cTrkVar[iTrkVar] -> SetLeftMargin(fMarginL);
    cTrkVar[iTrkVar] -> SetRightMargin(fMarginR1);
    cTrkVar[iTrkVar] -> SetTopMargin(fMarginT);
    cTrkVar[iTrkVar] -> SetBottomMargin(fMarginB);
    cTrkVar[iTrkVar] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hTrkVar[typesToDraw[iToDraw]][iTrkVar] -> Draw();
      } else {
        hTrkVar[typesToDraw[iToDraw]][iTrkVar] -> Draw("same");
      }
    }  // end to-draw loop
    leg              -> Draw();
    ptTxt            -> Draw();
    ptCut            -> Draw();
    cTrkVar[iTrkVar] -> Write();
    cTrkVar[iTrkVar] -> Close();

    // 1d track difference
    cTrkVarDiff[iTrkVar] = new TCanvas(sTrkVarDiff[iTrkVar].Data(), "", fWidth1P, fHeight1P);
    cTrkVarDiff[iTrkVar] -> SetGrid(fGrid, fGrid);
    cTrkVarDiff[iTrkVar] -> SetTicks(fTick, fTick);
    cTrkVarDiff[iTrkVar] -> SetLogx(fLogX);
    cTrkVarDiff[iTrkVar] -> SetLogy(fLogY);
    cTrkVarDiff[iTrkVar] -> SetLogz(fLogZ);
    cTrkVarDiff[iTrkVar] -> SetBorderMode(fMode);
    cTrkVarDiff[iTrkVar] -> SetBorderSize(fBord);
    cTrkVarDiff[iTrkVar] -> SetFrameBorderMode(fFrame);
    cTrkVarDiff[iTrkVar] -> SetLeftMargin(fMarginL);
    cTrkVarDiff[iTrkVar] -> SetRightMargin(fMarginR1);
    cTrkVarDiff[iTrkVar] -> SetTopMargin(fMarginT);
    cTrkVarDiff[iTrkVar] -> SetBottomMargin(fMarginB);
    cTrkVarDiff[iTrkVar] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hTrkVarDiff[typesToDraw[iToDraw]][iTrkVar] -> Draw();
      } else {
        hTrkVarDiff[typesToDraw[iToDraw]][iTrkVar] -> Draw("same");
      }
    }  // end to-draw loop
    leg                  -> Draw();
    ptTxt                -> Draw();
    ptCut                -> Draw();
    cTrkVarDiff[iTrkVar] -> Write();
    cTrkVarDiff[iTrkVar] -> Close();

    // 1d track fraction
    cTrkVarFrac[iTrkVar] = new TCanvas(sTrkVarFrac[iTrkVar].Data(), "", fWidth1P, fHeight1P);
    cTrkVarFrac[iTrkVar] -> SetGrid(fGrid, fGrid);
    cTrkVarFrac[iTrkVar] -> SetTicks(fTick, fTick);
    cTrkVarFrac[iTrkVar] -> SetLogx(fLogX);
    cTrkVarFrac[iTrkVar] -> SetLogy(fLogY);
    cTrkVarFrac[iTrkVar] -> SetLogz(fLogZ);
    cTrkVarFrac[iTrkVar] -> SetBorderMode(fMode);
    cTrkVarFrac[iTrkVar] -> SetBorderSize(fBord);
    cTrkVarFrac[iTrkVar] -> SetFrameBorderMode(fFrame);
    cTrkVarFrac[iTrkVar] -> SetLeftMargin(fMarginL);
    cTrkVarFrac[iTrkVar] -> SetRightMargin(fMarginR1);
    cTrkVarFrac[iTrkVar] -> SetTopMargin(fMarginT);
    cTrkVarFrac[iTrkVar] -> SetBottomMargin(fMarginB);
    cTrkVarFrac[iTrkVar] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hTrkVarFrac[typesToDraw[iToDraw]][iTrkVar] -> Draw();
      } else {
        hTrkVarFrac[typesToDraw[iToDraw]][iTrkVar] -> Draw("same");
      }
    }  // end to-draw loop
    leg                  -> Draw();
    ptTxt                -> Draw();
    ptCut                -> Draw();
    cTrkVarFrac[iTrkVar] -> Write();
    cTrkVarFrac[iTrkVar] -> Close();

    // 2d track variables vs. ntpc
    cTrkVarVsNTpc[iTrkVar]    = new TCanvas(sTrkVarVsNTpc[iTrkVar].Data(), "", fWidth2P, fHeight2P);
    pTrkVarVsNTpc[iTrkVar][0] = new TPad(sOneVsTwoDimPanels[0].Data(), "", padXY[0][0], padXY[0][1], padXY[0][2], padXY[0][3]);
    pTrkVarVsNTpc[iTrkVar][1] = new TPad(sOneVsTwoDimPanels[1].Data(), "", padXY[1][0], padXY[1][1], padXY[1][2], padXY[1][3]);
    cTrkVarVsNTpc[iTrkVar]    -> SetGrid(fGrid, fGrid);
    cTrkVarVsNTpc[iTrkVar]    -> SetTicks(fTick, fTick);
    cTrkVarVsNTpc[iTrkVar]    -> SetBorderMode(fMode);
    cTrkVarVsNTpc[iTrkVar]    -> SetBorderSize(fBord);
    pTrkVarVsNTpc[iTrkVar][0] -> SetGrid(fGrid, fGrid);
    pTrkVarVsNTpc[iTrkVar][0] -> SetTicks(fTick, fTick);
    pTrkVarVsNTpc[iTrkVar][0] -> SetLogx(fLogX);
    pTrkVarVsNTpc[iTrkVar][0] -> SetLogy(fLogY);
    pTrkVarVsNTpc[iTrkVar][0] -> SetLogz(fLogZ);
    pTrkVarVsNTpc[iTrkVar][0] -> SetBorderMode(fMode);
    pTrkVarVsNTpc[iTrkVar][0] -> SetBorderSize(fBord);
    pTrkVarVsNTpc[iTrkVar][0] -> SetFrameBorderMode(fFrame);
    pTrkVarVsNTpc[iTrkVar][0] -> SetLeftMargin(fMarginL);
    pTrkVarVsNTpc[iTrkVar][0] -> SetRightMargin(fMarginR1);
    pTrkVarVsNTpc[iTrkVar][0] -> SetTopMargin(fMarginT);
    pTrkVarVsNTpc[iTrkVar][0] -> SetBottomMargin(fMarginB);
    pTrkVarVsNTpc[iTrkVar][1] -> SetGrid(fGrid, fGrid);
    pTrkVarVsNTpc[iTrkVar][1] -> SetTicks(fTick, fTick);
    pTrkVarVsNTpc[iTrkVar][1] -> SetLogx(fLogX);
    pTrkVarVsNTpc[iTrkVar][1] -> SetLogy(fLogY);
    pTrkVarVsNTpc[iTrkVar][1] -> SetLogz(fLogZ);
    pTrkVarVsNTpc[iTrkVar][1] -> SetBorderMode(fMode);
    pTrkVarVsNTpc[iTrkVar][1] -> SetBorderSize(fBord);
    pTrkVarVsNTpc[iTrkVar][1] -> SetFrameBorderMode(fFrame);
    pTrkVarVsNTpc[iTrkVar][1] -> SetLeftMargin(fMarginL);
    pTrkVarVsNTpc[iTrkVar][1] -> SetRightMargin(fMarginR2);
    pTrkVarVsNTpc[iTrkVar][1] -> SetTopMargin(fMarginT);
    pTrkVarVsNTpc[iTrkVar][1] -> SetBottomMargin(fMarginB);
    cTrkVarVsNTpc[iTrkVar]    -> cd();
    pTrkVarVsNTpc[iTrkVar][0] -> Draw();
    pTrkVarVsNTpc[iTrkVar][1] -> Draw();
    pTrkVarVsNTpc[iTrkVar][0] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hTrkVar[typesToDraw[iToDraw]][iTrkVar] -> Draw();
      } else {
        hTrkVar[typesToDraw[iToDraw]][iTrkVar] -> Draw("same");
      }
    }  // end to-draw loop
    leg                       -> Draw();
    ptTxt                     -> Draw();
    ptCut                     -> Draw();
    pTrkVarVsNTpc[iTrkVar][1] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hTrkVarVsNTpc[typesToDraw[iToDraw]][iTrkVar] -> Draw("colz");
      } else {
        hTrkVarVsNTpc[typesToDraw[iToDraw]][iTrkVar] -> Draw("scat same");
      }
    }  // end to-draw loop
    cTrkVarVsNTpc[iTrkVar] -> Write();
    cTrkVarVsNTpc[iTrkVar] -> Close();

    // 2d track variables vs. dcaxy
    cTrkVarVsDcaXY[iTrkVar]    = new TCanvas(sTrkVarVsDcaXY[iTrkVar].Data(), "", fWidth2P, fHeight2P);
    pTrkVarVsDcaXY[iTrkVar][0] = new TPad(sOneVsTwoDimPanels[0].Data(), "", padXY[0][0], padXY[0][1], padXY[0][2], padXY[0][3]);
    pTrkVarVsDcaXY[iTrkVar][1] = new TPad(sOneVsTwoDimPanels[1].Data(), "", padXY[1][0], padXY[1][1], padXY[1][2], padXY[1][3]);
    cTrkVarVsDcaXY[iTrkVar]    -> SetGrid(fGrid, fGrid);
    cTrkVarVsDcaXY[iTrkVar]    -> SetTicks(fTick, fTick);
    cTrkVarVsDcaXY[iTrkVar]    -> SetBorderMode(fMode);
    cTrkVarVsDcaXY[iTrkVar]    -> SetBorderSize(fBord);
    pTrkVarVsDcaXY[iTrkVar][0] -> SetGrid(fGrid, fGrid);
    pTrkVarVsDcaXY[iTrkVar][0] -> SetTicks(fTick, fTick);
    pTrkVarVsDcaXY[iTrkVar][0] -> SetLogx(fLogX);
    pTrkVarVsDcaXY[iTrkVar][0] -> SetLogy(fLogY);
    pTrkVarVsDcaXY[iTrkVar][0] -> SetLogz(fLogZ);
    pTrkVarVsDcaXY[iTrkVar][0] -> SetBorderMode(fMode);
    pTrkVarVsDcaXY[iTrkVar][0] -> SetBorderSize(fBord);
    pTrkVarVsDcaXY[iTrkVar][0] -> SetFrameBorderMode(fFrame);
    pTrkVarVsDcaXY[iTrkVar][0] -> SetLeftMargin(fMarginL);
    pTrkVarVsDcaXY[iTrkVar][0] -> SetRightMargin(fMarginR1);
    pTrkVarVsDcaXY[iTrkVar][0] -> SetTopMargin(fMarginT);
    pTrkVarVsDcaXY[iTrkVar][0] -> SetBottomMargin(fMarginB);
    pTrkVarVsDcaXY[iTrkVar][1] -> SetGrid(fGrid, fGrid);
    pTrkVarVsDcaXY[iTrkVar][1] -> SetTicks(fTick, fTick);
    pTrkVarVsDcaXY[iTrkVar][1] -> SetLogx(fLogX);
    pTrkVarVsDcaXY[iTrkVar][1] -> SetLogy(fLogY);
    pTrkVarVsDcaXY[iTrkVar][1] -> SetLogz(fLogZ);
    pTrkVarVsDcaXY[iTrkVar][1] -> SetBorderMode(fMode);
    pTrkVarVsDcaXY[iTrkVar][1] -> SetBorderSize(fBord);
    pTrkVarVsDcaXY[iTrkVar][1] -> SetFrameBorderMode(fFrame);
    pTrkVarVsDcaXY[iTrkVar][1] -> SetLeftMargin(fMarginL);
    pTrkVarVsDcaXY[iTrkVar][1] -> SetRightMargin(fMarginR2);
    pTrkVarVsDcaXY[iTrkVar][1] -> SetTopMargin(fMarginT);
    pTrkVarVsDcaXY[iTrkVar][1] -> SetBottomMargin(fMarginB);
    cTrkVarVsDcaXY[iTrkVar]    -> cd();
    pTrkVarVsDcaXY[iTrkVar][0] -> Draw();
    pTrkVarVsDcaXY[iTrkVar][1] -> Draw();
    pTrkVarVsDcaXY[iTrkVar][0] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hTrkVar[typesToDraw[iToDraw]][iTrkVar] -> Draw();
      } else {
        hTrkVar[typesToDraw[iToDraw]][iTrkVar] -> Draw("same");
      }
    }  // end to-draw loop
    leg                        -> Draw();
    ptTxt                      -> Draw();
    ptCut                      -> Draw();
    pTrkVarVsDcaXY[iTrkVar][1] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hTrkVarVsDcaXY[typesToDraw[iToDraw]][iTrkVar] -> Draw("colz");
      } else {
        hTrkVarVsDcaXY[typesToDraw[iToDraw]][iTrkVar] -> Draw("scat same");
      }
    }  // end to-draw loop
    cTrkVarVsDcaXY[iTrkVar] -> Write();
    cTrkVarVsDcaXY[iTrkVar] -> Close();

    // 2d track variables vs. dcaz
    cTrkVarVsDcaZ[iTrkVar]    = new TCanvas(sTrkVarVsDcaZ[iTrkVar].Data(), "", fWidth2P, fHeight2P);
    pTrkVarVsDcaZ[iTrkVar][0] = new TPad(sOneVsTwoDimPanels[0].Data(), "", padXY[0][0], padXY[0][1], padXY[0][2], padXY[0][3]);
    pTrkVarVsDcaZ[iTrkVar][1] = new TPad(sOneVsTwoDimPanels[1].Data(), "", padXY[1][0], padXY[1][1], padXY[1][2], padXY[1][3]);
    cTrkVarVsDcaZ[iTrkVar]    -> SetGrid(fGrid, fGrid);
    cTrkVarVsDcaZ[iTrkVar]    -> SetTicks(fTick, fTick);
    cTrkVarVsDcaZ[iTrkVar]    -> SetBorderMode(fMode);
    cTrkVarVsDcaZ[iTrkVar]    -> SetBorderSize(fBord);
    pTrkVarVsDcaZ[iTrkVar][0] -> SetGrid(fGrid, fGrid);
    pTrkVarVsDcaZ[iTrkVar][0] -> SetTicks(fTick, fTick);
    pTrkVarVsDcaZ[iTrkVar][0] -> SetLogx(fLogX);
    pTrkVarVsDcaZ[iTrkVar][0] -> SetLogy(fLogY);
    pTrkVarVsDcaZ[iTrkVar][0] -> SetLogz(fLogZ);
    pTrkVarVsDcaZ[iTrkVar][0] -> SetBorderMode(fMode);
    pTrkVarVsDcaZ[iTrkVar][0] -> SetBorderSize(fBord);
    pTrkVarVsDcaZ[iTrkVar][0] -> SetFrameBorderMode(fFrame);
    pTrkVarVsDcaZ[iTrkVar][0] -> SetLeftMargin(fMarginL);
    pTrkVarVsDcaZ[iTrkVar][0] -> SetRightMargin(fMarginR1);
    pTrkVarVsDcaZ[iTrkVar][0] -> SetTopMargin(fMarginT);
    pTrkVarVsDcaZ[iTrkVar][0] -> SetBottomMargin(fMarginB);
    pTrkVarVsDcaZ[iTrkVar][1] -> SetGrid(fGrid, fGrid);
    pTrkVarVsDcaZ[iTrkVar][1] -> SetTicks(fTick, fTick);
    pTrkVarVsDcaZ[iTrkVar][1] -> SetLogx(fLogX);
    pTrkVarVsDcaZ[iTrkVar][1] -> SetLogy(fLogY);
    pTrkVarVsDcaZ[iTrkVar][1] -> SetLogz(fLogZ);
    pTrkVarVsDcaZ[iTrkVar][1] -> SetBorderMode(fMode);
    pTrkVarVsDcaZ[iTrkVar][1] -> SetBorderSize(fBord);
    pTrkVarVsDcaZ[iTrkVar][1] -> SetFrameBorderMode(fFrame);
    pTrkVarVsDcaZ[iTrkVar][1] -> SetLeftMargin(fMarginL);
    pTrkVarVsDcaZ[iTrkVar][1] -> SetRightMargin(fMarginR2);
    pTrkVarVsDcaZ[iTrkVar][1] -> SetTopMargin(fMarginT);
    pTrkVarVsDcaZ[iTrkVar][1] -> SetBottomMargin(fMarginB);
    cTrkVarVsDcaZ[iTrkVar]    -> cd();
    pTrkVarVsDcaZ[iTrkVar][0] -> Draw();
    pTrkVarVsDcaZ[iTrkVar][1] -> Draw();
    pTrkVarVsDcaZ[iTrkVar][0] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hTrkVar[typesToDraw[iToDraw]][iTrkVar] -> Draw();
      } else {
        hTrkVar[typesToDraw[iToDraw]][iTrkVar] -> Draw("same");
      }
    }  // end to-draw loop
    leg                       -> Draw();
    ptTxt                     -> Draw();
    ptCut                     -> Draw();
    pTrkVarVsDcaZ[iTrkVar][1] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hTrkVarVsDcaZ[typesToDraw[iToDraw]][iTrkVar] -> Draw("colz");
      } else {
        hTrkVarVsDcaZ[typesToDraw[iToDraw]][iTrkVar] -> Draw("scat same");
      }
    }  // end to-draw loop
    cTrkVarVsDcaZ[iTrkVar] -> Write();
    cTrkVarVsDcaZ[iTrkVar] -> Close();

    // 2d track variables vs. ptreco
    cTrkVarVsPtReco[iTrkVar]    = new TCanvas(sTrkVarVsPtReco[iTrkVar].Data(), "", fWidth2P, fHeight2P);
    pTrkVarVsPtReco[iTrkVar][0] = new TPad(sOneVsTwoDimPanels[0].Data(), "", padXY[0][0], padXY[0][1], padXY[0][2], padXY[0][3]);
    pTrkVarVsPtReco[iTrkVar][1] = new TPad(sOneVsTwoDimPanels[1].Data(), "", padXY[1][0], padXY[1][1], padXY[1][2], padXY[1][3]);
    cTrkVarVsPtReco[iTrkVar]    -> SetGrid(fGrid, fGrid);
    cTrkVarVsPtReco[iTrkVar]    -> SetTicks(fTick, fTick);
    cTrkVarVsPtReco[iTrkVar]    -> SetBorderMode(fMode);
    cTrkVarVsPtReco[iTrkVar]    -> SetBorderSize(fBord);
    pTrkVarVsPtReco[iTrkVar][0] -> SetGrid(fGrid, fGrid);
    pTrkVarVsPtReco[iTrkVar][0] -> SetTicks(fTick, fTick);
    pTrkVarVsPtReco[iTrkVar][0] -> SetLogx(fLogX);
    pTrkVarVsPtReco[iTrkVar][0] -> SetLogy(fLogY);
    pTrkVarVsPtReco[iTrkVar][0] -> SetLogz(fLogZ);
    pTrkVarVsPtReco[iTrkVar][0] -> SetBorderMode(fMode);
    pTrkVarVsPtReco[iTrkVar][0] -> SetBorderSize(fBord);
    pTrkVarVsPtReco[iTrkVar][0] -> SetFrameBorderMode(fFrame);
    pTrkVarVsPtReco[iTrkVar][0] -> SetLeftMargin(fMarginL);
    pTrkVarVsPtReco[iTrkVar][0] -> SetRightMargin(fMarginR1);
    pTrkVarVsPtReco[iTrkVar][0] -> SetTopMargin(fMarginT);
    pTrkVarVsPtReco[iTrkVar][0] -> SetBottomMargin(fMarginB);
    pTrkVarVsPtReco[iTrkVar][1] -> SetGrid(fGrid, fGrid);
    pTrkVarVsPtReco[iTrkVar][1] -> SetTicks(fTick, fTick);
    pTrkVarVsPtReco[iTrkVar][1] -> SetLogx(fLogX);
    pTrkVarVsPtReco[iTrkVar][1] -> SetLogy(fLogY);
    pTrkVarVsPtReco[iTrkVar][1] -> SetLogz(fLogZ);
    pTrkVarVsPtReco[iTrkVar][1] -> SetBorderMode(fMode);
    pTrkVarVsPtReco[iTrkVar][1] -> SetBorderSize(fBord);
    pTrkVarVsPtReco[iTrkVar][1] -> SetFrameBorderMode(fFrame);
    pTrkVarVsPtReco[iTrkVar][1] -> SetLeftMargin(fMarginL);
    pTrkVarVsPtReco[iTrkVar][1] -> SetRightMargin(fMarginR2);
    pTrkVarVsPtReco[iTrkVar][1] -> SetTopMargin(fMarginT);
    pTrkVarVsPtReco[iTrkVar][1] -> SetBottomMargin(fMarginB);
    cTrkVarVsPtReco[iTrkVar]    -> cd();
    pTrkVarVsPtReco[iTrkVar][0] -> Draw();
    pTrkVarVsPtReco[iTrkVar][1] -> Draw();
    pTrkVarVsPtReco[iTrkVar][0] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hTrkVar[typesToDraw[iToDraw]][iTrkVar] -> Draw();
      } else {
        hTrkVar[typesToDraw[iToDraw]][iTrkVar] -> Draw("same");
      }
    }  // end to-draw loop
    leg                         -> Draw();
    ptTxt                       -> Draw();
    ptCut                       -> Draw();
    pTrkVarVsPtReco[iTrkVar][1] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hTrkVarVsPtReco[typesToDraw[iToDraw]][iTrkVar] -> Draw("colz");
      } else {
        hTrkVarVsPtReco[typesToDraw[iToDraw]][iTrkVar] -> Draw("scat same");
      }
    }  // end to-draw loop
    cTrkVarVsPtReco[iTrkVar] -> Write();
    cTrkVarVsPtReco[iTrkVar] -> Close();

    // 2d track variables vs. pttrue
    cTrkVarVsPtTrue[iTrkVar]    = new TCanvas(sTrkVarVsPtTrue[iTrkVar].Data(), "", fWidth2P, fHeight2P);
    pTrkVarVsPtTrue[iTrkVar][0] = new TPad(sOneVsTwoDimPanels[0].Data(), "", padXY[0][0], padXY[0][1], padXY[0][2], padXY[0][3]);
    pTrkVarVsPtTrue[iTrkVar][1] = new TPad(sOneVsTwoDimPanels[1].Data(), "", padXY[1][0], padXY[1][1], padXY[1][2], padXY[1][3]);
    cTrkVarVsPtTrue[iTrkVar]    -> SetGrid(fGrid, fGrid);
    cTrkVarVsPtTrue[iTrkVar]    -> SetTicks(fTick, fTick);
    cTrkVarVsPtTrue[iTrkVar]    -> SetBorderMode(fMode);
    cTrkVarVsPtTrue[iTrkVar]    -> SetBorderSize(fBord);
    pTrkVarVsPtTrue[iTrkVar][0] -> SetGrid(fGrid, fGrid);
    pTrkVarVsPtTrue[iTrkVar][0] -> SetTicks(fTick, fTick);
    pTrkVarVsPtTrue[iTrkVar][0] -> SetLogx(fLogX);
    pTrkVarVsPtTrue[iTrkVar][0] -> SetLogy(fLogY);
    pTrkVarVsPtTrue[iTrkVar][0] -> SetLogz(fLogZ);
    pTrkVarVsPtTrue[iTrkVar][0] -> SetBorderMode(fMode);
    pTrkVarVsPtTrue[iTrkVar][0] -> SetBorderSize(fBord);
    pTrkVarVsPtTrue[iTrkVar][0] -> SetFrameBorderMode(fFrame);
    pTrkVarVsPtTrue[iTrkVar][0] -> SetLeftMargin(fMarginL);
    pTrkVarVsPtTrue[iTrkVar][0] -> SetRightMargin(fMarginR1);
    pTrkVarVsPtTrue[iTrkVar][0] -> SetTopMargin(fMarginT);
    pTrkVarVsPtTrue[iTrkVar][0] -> SetBottomMargin(fMarginB);
    pTrkVarVsPtTrue[iTrkVar][1] -> SetGrid(fGrid, fGrid);
    pTrkVarVsPtTrue[iTrkVar][1] -> SetTicks(fTick, fTick);
    pTrkVarVsPtTrue[iTrkVar][1] -> SetLogx(fLogX);
    pTrkVarVsPtTrue[iTrkVar][1] -> SetLogy(fLogY);
    pTrkVarVsPtTrue[iTrkVar][1] -> SetLogz(fLogZ);
    pTrkVarVsPtTrue[iTrkVar][1] -> SetBorderMode(fMode);
    pTrkVarVsPtTrue[iTrkVar][1] -> SetBorderSize(fBord);
    pTrkVarVsPtTrue[iTrkVar][1] -> SetFrameBorderMode(fFrame);
    pTrkVarVsPtTrue[iTrkVar][1] -> SetLeftMargin(fMarginL);
    pTrkVarVsPtTrue[iTrkVar][1] -> SetRightMargin(fMarginR2);
    pTrkVarVsPtTrue[iTrkVar][1] -> SetTopMargin(fMarginT);
    pTrkVarVsPtTrue[iTrkVar][1] -> SetBottomMargin(fMarginB);
    cTrkVarVsPtTrue[iTrkVar]    -> cd();
    pTrkVarVsPtTrue[iTrkVar][0] -> Draw();
    pTrkVarVsPtTrue[iTrkVar][1] -> Draw();
    pTrkVarVsPtTrue[iTrkVar][0] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hTrkVar[typesToDraw[iToDraw]][iTrkVar] -> Draw();
      } else {
        hTrkVar[typesToDraw[iToDraw]][iTrkVar] -> Draw("same");
      }
    }  // end to-draw loop
    leg                         -> Draw();
    ptTxt                       -> Draw();
    ptCut                       -> Draw();
    pTrkVarVsPtTrue[iTrkVar][1] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hTrkVarVsPtTrue[typesToDraw[iToDraw]][iTrkVar] -> Draw("colz");
      } else {
        hTrkVarVsPtTrue[typesToDraw[iToDraw]][iTrkVar] -> Draw("scat same");
      }
    }  // end to-draw loop
    cTrkVarVsPtTrue[iTrkVar] -> Write();
    cTrkVarVsPtTrue[iTrkVar] -> Close();

    // 2d track variables vs. pttrue
    cTrkVarVsPtFrac[iTrkVar]    = new TCanvas(sTrkVarVsPtFrac[iTrkVar].Data(), "", fWidth2P, fHeight2P);
    pTrkVarVsPtFrac[iTrkVar][0] = new TPad(sOneVsTwoDimPanels[0].Data(), "", padXY[0][0], padXY[0][1], padXY[0][2], padXY[0][3]);
    pTrkVarVsPtFrac[iTrkVar][1] = new TPad(sOneVsTwoDimPanels[1].Data(), "", padXY[1][0], padXY[1][1], padXY[1][2], padXY[1][3]);
    cTrkVarVsPtFrac[iTrkVar]    -> SetGrid(fGrid, fGrid);
    cTrkVarVsPtFrac[iTrkVar]    -> SetTicks(fTick, fTick);
    cTrkVarVsPtFrac[iTrkVar]    -> SetBorderMode(fMode);
    cTrkVarVsPtFrac[iTrkVar]    -> SetBorderSize(fBord);
    pTrkVarVsPtFrac[iTrkVar][0] -> SetGrid(fGrid, fGrid);
    pTrkVarVsPtFrac[iTrkVar][0] -> SetTicks(fTick, fTick);
    pTrkVarVsPtFrac[iTrkVar][0] -> SetLogx(fLogX);
    pTrkVarVsPtFrac[iTrkVar][0] -> SetLogy(fLogY);
    pTrkVarVsPtFrac[iTrkVar][0] -> SetLogz(fLogZ);
    pTrkVarVsPtFrac[iTrkVar][0] -> SetBorderMode(fMode);
    pTrkVarVsPtFrac[iTrkVar][0] -> SetBorderSize(fBord);
    pTrkVarVsPtFrac[iTrkVar][0] -> SetFrameBorderMode(fFrame);
    pTrkVarVsPtFrac[iTrkVar][0] -> SetLeftMargin(fMarginL);
    pTrkVarVsPtFrac[iTrkVar][0] -> SetRightMargin(fMarginR1);
    pTrkVarVsPtFrac[iTrkVar][0] -> SetTopMargin(fMarginT);
    pTrkVarVsPtFrac[iTrkVar][0] -> SetBottomMargin(fMarginB);
    pTrkVarVsPtFrac[iTrkVar][1] -> SetGrid(fGrid, fGrid);
    pTrkVarVsPtFrac[iTrkVar][1] -> SetTicks(fTick, fTick);
    pTrkVarVsPtFrac[iTrkVar][1] -> SetLogx(fLogX);
    pTrkVarVsPtFrac[iTrkVar][1] -> SetLogy(fLogY);
    pTrkVarVsPtFrac[iTrkVar][1] -> SetLogz(fLogZ);
    pTrkVarVsPtFrac[iTrkVar][1] -> SetBorderMode(fMode);
    pTrkVarVsPtFrac[iTrkVar][1] -> SetBorderSize(fBord);
    pTrkVarVsPtFrac[iTrkVar][1] -> SetFrameBorderMode(fFrame);
    pTrkVarVsPtFrac[iTrkVar][1] -> SetLeftMargin(fMarginL);
    pTrkVarVsPtFrac[iTrkVar][1] -> SetRightMargin(fMarginR2);
    pTrkVarVsPtFrac[iTrkVar][1] -> SetTopMargin(fMarginT);
    pTrkVarVsPtFrac[iTrkVar][1] -> SetBottomMargin(fMarginB);
    cTrkVarVsPtFrac[iTrkVar]    -> cd();
    pTrkVarVsPtFrac[iTrkVar][0] -> Draw();
    pTrkVarVsPtFrac[iTrkVar][1] -> Draw();
    pTrkVarVsPtFrac[iTrkVar][0] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hTrkVar[typesToDraw[iToDraw]][iTrkVar] -> Draw();
      } else {
        hTrkVar[typesToDraw[iToDraw]][iTrkVar] -> Draw("same");
      }
    }  // end to-draw loop
    leg                         -> Draw();
    ptTxt                       -> Draw();
    ptCut                       -> Draw();
    pTrkVarVsPtFrac[iTrkVar][1] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hTrkVarVsPtFrac[typesToDraw[iToDraw]][iTrkVar] -> Draw("colz");
      } else {
        hTrkVarVsPtFrac[typesToDraw[iToDraw]][iTrkVar] -> Draw("scat same");
      }
    }  // end to-draw loop
    cTrkVarVsPtFrac[iTrkVar] -> Write();
    cTrkVarVsPtFrac[iTrkVar] -> Close();
  }  // end track variable loop

  // for physics-variable plots
  TCanvas *cPhysVar[NPhysVar];
  TCanvas *cPhysVarDiff[NPhysVar];
  TCanvas *cPhysVarFrac[NPhysVar];
  TCanvas *cPhysVarVsNTpc[NPhysVar];
  TCanvas *cPhysVarVsDcaXY[NPhysVar];
  TCanvas *cPhysVarVsDcaZ[NPhysVar];
  TCanvas *cPhysVarVsPtReco[NPhysVar];
  TCanvas *cPhysVarVsPtTrue[NPhysVar];
  TCanvas *cPhysVarVsPtFrac[NPhysVar];
  TPad    *pPhysVarVsNTpc[NPhysVar][NPanel];
  TPad    *pPhysVarVsDcaXY[NPhysVar][NPanel];
  TPad    *pPhysVarVsDcaZ[NPhysVar][NPanel];
  TPad    *pPhysVarVsPtReco[NPhysVar][NPanel];
  TPad    *pPhysVarVsPtTrue[NPhysVar][NPanel];
  TPad    *pPhysVarVsPtFrac[NPhysVar][NPanel];
  for (size_t iPhysVar = 0; iPhysVar < NPhysVar; iPhysVar++) {

    // 1d physics variable
    cPhysVar[iPhysVar] = new TCanvas(sPhysVar[iPhysVar].Data(), "", fWidth1P, fHeight1P);
    cPhysVar[iPhysVar] -> SetGrid(fGrid, fGrid);
    cPhysVar[iPhysVar] -> SetTicks(fTick, fTick);
    cPhysVar[iPhysVar] -> SetLogx(fLogX);
    cPhysVar[iPhysVar] -> SetLogy(fLogY);
    cPhysVar[iPhysVar] -> SetLogz(fLogZ);
    cPhysVar[iPhysVar] -> SetBorderMode(fMode);
    cPhysVar[iPhysVar] -> SetBorderSize(fBord);
    cPhysVar[iPhysVar] -> SetFrameBorderMode(fFrame);
    cPhysVar[iPhysVar] -> SetLeftMargin(fMarginL);
    cPhysVar[iPhysVar] -> SetRightMargin(fMarginR1);
    cPhysVar[iPhysVar] -> SetTopMargin(fMarginT);
    cPhysVar[iPhysVar] -> SetBottomMargin(fMarginB);
    cPhysVar[iPhysVar] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hPhysVar[typesToDraw[iToDraw]][iPhysVar] -> Draw();
      } else {
        hPhysVar[typesToDraw[iToDraw]][iPhysVar] -> Draw("same");
      }
    }  // end to-draw loop
    leg                -> Draw();
    ptTxt              -> Draw();
    ptCut              -> Draw();
    cPhysVar[iPhysVar] -> Write();
    cPhysVar[iPhysVar] -> Close();

    // 1d physics difference
    cPhysVarDiff[iPhysVar] = new TCanvas(sPhysVarDiff[iPhysVar].Data(), "", fWidth1P, fHeight1P);
    cPhysVarDiff[iPhysVar] -> SetGrid(fGrid, fGrid);
    cPhysVarDiff[iPhysVar] -> SetTicks(fTick, fTick);
    cPhysVarDiff[iPhysVar] -> SetLogx(fLogX);
    cPhysVarDiff[iPhysVar] -> SetLogy(fLogY);
    cPhysVarDiff[iPhysVar] -> SetLogz(fLogZ);
    cPhysVarDiff[iPhysVar] -> SetBorderMode(fMode);
    cPhysVarDiff[iPhysVar] -> SetBorderSize(fBord);
    cPhysVarDiff[iPhysVar] -> SetFrameBorderMode(fFrame);
    cPhysVarDiff[iPhysVar] -> SetLeftMargin(fMarginL);
    cPhysVarDiff[iPhysVar] -> SetRightMargin(fMarginR1);
    cPhysVarDiff[iPhysVar] -> SetTopMargin(fMarginT);
    cPhysVarDiff[iPhysVar] -> SetBottomMargin(fMarginB);
    cPhysVarDiff[iPhysVar] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hPhysVarDiff[typesToDraw[iToDraw]][iPhysVar] -> Draw();
      } else {
        hPhysVarDiff[typesToDraw[iToDraw]][iPhysVar] -> Draw("same");
      }
    }  // end to-draw loop
    leg                    -> Draw();
    ptTxt                  -> Draw();
    ptCut                  -> Draw();
    cPhysVarDiff[iPhysVar] -> Write();
    cPhysVarDiff[iPhysVar] -> Close();

    // 1d physics fraction
    cPhysVarFrac[iPhysVar] = new TCanvas(sPhysVarFrac[iPhysVar].Data(), "", fWidth1P, fHeight1P);
    cPhysVarFrac[iPhysVar] -> SetGrid(fGrid, fGrid);
    cPhysVarFrac[iPhysVar] -> SetTicks(fTick, fTick);
    cPhysVarFrac[iPhysVar] -> SetLogx(fLogX);
    cPhysVarFrac[iPhysVar] -> SetLogy(fLogY);
    cPhysVarFrac[iPhysVar] -> SetLogz(fLogZ);
    cPhysVarFrac[iPhysVar] -> SetBorderMode(fMode);
    cPhysVarFrac[iPhysVar] -> SetBorderSize(fBord);
    cPhysVarFrac[iPhysVar] -> SetFrameBorderMode(fFrame);
    cPhysVarFrac[iPhysVar] -> SetLeftMargin(fMarginL);
    cPhysVarFrac[iPhysVar] -> SetRightMargin(fMarginR1);
    cPhysVarFrac[iPhysVar] -> SetTopMargin(fMarginT);
    cPhysVarFrac[iPhysVar] -> SetBottomMargin(fMarginB);
    cPhysVarFrac[iPhysVar] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hPhysVarFrac[typesToDraw[iToDraw]][iPhysVar] -> Draw();
      } else {
        hPhysVarFrac[typesToDraw[iToDraw]][iPhysVar] -> Draw("same");
      }
    }  // end to-draw loop
    leg                    -> Draw();
    ptTxt                  -> Draw();
    ptCut                  -> Draw();
    cPhysVarFrac[iPhysVar] -> Write();
    cPhysVarFrac[iPhysVar] -> Close();

    // 2d physics variables vs. ntpc
    cPhysVarVsNTpc[iPhysVar]    = new TCanvas(sPhysVarVsNTpc[iPhysVar].Data(), "", fWidth2P, fHeight2P);
    pPhysVarVsNTpc[iPhysVar][0] = new TPad(sOneVsTwoDimPanels[0].Data(), "", padXY[0][0], padXY[0][1], padXY[0][2], padXY[0][3]);
    pPhysVarVsNTpc[iPhysVar][1] = new TPad(sOneVsTwoDimPanels[1].Data(), "", padXY[1][0], padXY[1][1], padXY[1][2], padXY[1][3]);
    cPhysVarVsNTpc[iPhysVar]    -> SetGrid(fGrid, fGrid);
    cPhysVarVsNTpc[iPhysVar]    -> SetTicks(fTick, fTick);
    cPhysVarVsNTpc[iPhysVar]    -> SetBorderMode(fMode);
    cPhysVarVsNTpc[iPhysVar]    -> SetBorderSize(fBord);
    pPhysVarVsNTpc[iPhysVar][0] -> SetGrid(fGrid, fGrid);
    pPhysVarVsNTpc[iPhysVar][0] -> SetTicks(fTick, fTick);
    pPhysVarVsNTpc[iPhysVar][0] -> SetLogx(fLogX);
    pPhysVarVsNTpc[iPhysVar][0] -> SetLogy(fLogY);
    pPhysVarVsNTpc[iPhysVar][0] -> SetLogz(fLogZ);
    pPhysVarVsNTpc[iPhysVar][0] -> SetBorderMode(fMode);
    pPhysVarVsNTpc[iPhysVar][0] -> SetBorderSize(fBord);
    pPhysVarVsNTpc[iPhysVar][0] -> SetFrameBorderMode(fFrame);
    pPhysVarVsNTpc[iPhysVar][0] -> SetLeftMargin(fMarginL);
    pPhysVarVsNTpc[iPhysVar][0] -> SetRightMargin(fMarginR1);
    pPhysVarVsNTpc[iPhysVar][0] -> SetTopMargin(fMarginT);
    pPhysVarVsNTpc[iPhysVar][0] -> SetBottomMargin(fMarginB);
    pPhysVarVsNTpc[iPhysVar][1] -> SetGrid(fGrid, fGrid);
    pPhysVarVsNTpc[iPhysVar][1] -> SetTicks(fTick, fTick);
    pPhysVarVsNTpc[iPhysVar][1] -> SetLogx(fLogX);
    pPhysVarVsNTpc[iPhysVar][1] -> SetLogy(fLogY);
    pPhysVarVsNTpc[iPhysVar][1] -> SetLogz(fLogZ);
    pPhysVarVsNTpc[iPhysVar][1] -> SetBorderMode(fMode);
    pPhysVarVsNTpc[iPhysVar][1] -> SetBorderSize(fBord);
    pPhysVarVsNTpc[iPhysVar][1] -> SetFrameBorderMode(fFrame);
    pPhysVarVsNTpc[iPhysVar][1] -> SetLeftMargin(fMarginL);
    pPhysVarVsNTpc[iPhysVar][1] -> SetRightMargin(fMarginR2);
    pPhysVarVsNTpc[iPhysVar][1] -> SetTopMargin(fMarginT);
    pPhysVarVsNTpc[iPhysVar][1] -> SetBottomMargin(fMarginB);
    cPhysVarVsNTpc[iPhysVar]    -> cd();
    pPhysVarVsNTpc[iPhysVar][0] -> Draw();
    pPhysVarVsNTpc[iPhysVar][1] -> Draw();
    pPhysVarVsNTpc[iPhysVar][0] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hPhysVar[typesToDraw[iToDraw]][iPhysVar] -> Draw();
      } else {
        hPhysVar[typesToDraw[iToDraw]][iPhysVar] -> Draw("same");
      }
    }  // end to-draw loop
    leg                         -> Draw();
    ptTxt                       -> Draw();
    ptCut                       -> Draw();
    pPhysVarVsNTpc[iPhysVar][1] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hPhysVarVsNTpc[typesToDraw[iToDraw]][iPhysVar] -> Draw("colz");
      } else {
        hPhysVarVsNTpc[typesToDraw[iToDraw]][iPhysVar] -> Draw("scat same");
      }
    }  // end to-draw loop
    cPhysVarVsNTpc[iPhysVar] -> Write();
    cPhysVarVsNTpc[iPhysVar] -> Close();

    // 2d physics variables vs. dcaxy
    cPhysVarVsDcaXY[iPhysVar]    = new TCanvas(sPhysVarVsDcaXY[iPhysVar].Data(), "", fWidth2P, fHeight2P);
    pPhysVarVsDcaXY[iPhysVar][0] = new TPad(sOneVsTwoDimPanels[0].Data(), "", padXY[0][0], padXY[0][1], padXY[0][2], padXY[0][3]);
    pPhysVarVsDcaXY[iPhysVar][1] = new TPad(sOneVsTwoDimPanels[1].Data(), "", padXY[1][0], padXY[1][1], padXY[1][2], padXY[1][3]);
    cPhysVarVsDcaXY[iPhysVar]    -> SetGrid(fGrid, fGrid);
    cPhysVarVsDcaXY[iPhysVar]    -> SetTicks(fTick, fTick);
    cPhysVarVsDcaXY[iPhysVar]    -> SetBorderMode(fMode);
    cPhysVarVsDcaXY[iPhysVar]    -> SetBorderSize(fBord);
    pPhysVarVsDcaXY[iPhysVar][0] -> SetGrid(fGrid, fGrid);
    pPhysVarVsDcaXY[iPhysVar][0] -> SetTicks(fTick, fTick);
    pPhysVarVsDcaXY[iPhysVar][0] -> SetLogx(fLogX);
    pPhysVarVsDcaXY[iPhysVar][0] -> SetLogy(fLogY);
    pPhysVarVsDcaXY[iPhysVar][0] -> SetLogz(fLogZ);
    pPhysVarVsDcaXY[iPhysVar][0] -> SetBorderMode(fMode);
    pPhysVarVsDcaXY[iPhysVar][0] -> SetBorderSize(fBord);
    pPhysVarVsDcaXY[iPhysVar][0] -> SetFrameBorderMode(fFrame);
    pPhysVarVsDcaXY[iPhysVar][0] -> SetLeftMargin(fMarginL);
    pPhysVarVsDcaXY[iPhysVar][0] -> SetRightMargin(fMarginR1);
    pPhysVarVsDcaXY[iPhysVar][0] -> SetTopMargin(fMarginT);
    pPhysVarVsDcaXY[iPhysVar][0] -> SetBottomMargin(fMarginB);
    pPhysVarVsDcaXY[iPhysVar][1] -> SetGrid(fGrid, fGrid);
    pPhysVarVsDcaXY[iPhysVar][1] -> SetTicks(fTick, fTick);
    pPhysVarVsDcaXY[iPhysVar][1] -> SetLogx(fLogX);
    pPhysVarVsDcaXY[iPhysVar][1] -> SetLogy(fLogY);
    pPhysVarVsDcaXY[iPhysVar][1] -> SetLogz(fLogZ);
    pPhysVarVsDcaXY[iPhysVar][1] -> SetBorderMode(fMode);
    pPhysVarVsDcaXY[iPhysVar][1] -> SetBorderSize(fBord);
    pPhysVarVsDcaXY[iPhysVar][1] -> SetFrameBorderMode(fFrame);
    pPhysVarVsDcaXY[iPhysVar][1] -> SetLeftMargin(fMarginL);
    pPhysVarVsDcaXY[iPhysVar][1] -> SetRightMargin(fMarginR2);
    pPhysVarVsDcaXY[iPhysVar][1] -> SetTopMargin(fMarginT);
    pPhysVarVsDcaXY[iPhysVar][1] -> SetBottomMargin(fMarginB);
    cPhysVarVsDcaXY[iPhysVar]    -> cd();
    pPhysVarVsDcaXY[iPhysVar][0] -> Draw();
    pPhysVarVsDcaXY[iPhysVar][1] -> Draw();
    pPhysVarVsDcaXY[iPhysVar][0] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hPhysVar[typesToDraw[iToDraw]][iPhysVar] -> Draw();
      } else {
        hPhysVar[typesToDraw[iToDraw]][iPhysVar] -> Draw("same");
      }
    }  // end to-draw loop
    leg                          -> Draw();
    ptTxt                        -> Draw();
    ptCut                        -> Draw();
    pPhysVarVsDcaXY[iPhysVar][1] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hPhysVarVsDcaXY[typesToDraw[iToDraw]][iPhysVar] -> Draw("colz");
      } else {
        hPhysVarVsDcaXY[typesToDraw[iToDraw]][iPhysVar] -> Draw("scat same");
      }
    }  // end to-draw loop
    cPhysVarVsDcaXY[iPhysVar] -> Write();
    cPhysVarVsDcaXY[iPhysVar] -> Close();

    // 2d physics variables vs. dcaz
    cPhysVarVsDcaZ[iPhysVar]    = new TCanvas(sPhysVarVsDcaZ[iPhysVar].Data(), "", fWidth2P, fHeight2P);
    pPhysVarVsDcaZ[iPhysVar][0] = new TPad(sOneVsTwoDimPanels[0].Data(), "", padXY[0][0], padXY[0][1], padXY[0][2], padXY[0][3]);
    pPhysVarVsDcaZ[iPhysVar][1] = new TPad(sOneVsTwoDimPanels[1].Data(), "", padXY[1][0], padXY[1][1], padXY[1][2], padXY[1][3]);
    cPhysVarVsDcaZ[iPhysVar]    -> SetGrid(fGrid, fGrid);
    cPhysVarVsDcaZ[iPhysVar]    -> SetTicks(fTick, fTick);
    cPhysVarVsDcaZ[iPhysVar]    -> SetBorderMode(fMode);
    cPhysVarVsDcaZ[iPhysVar]    -> SetBorderSize(fBord);
    pPhysVarVsDcaZ[iPhysVar][0] -> SetGrid(fGrid, fGrid);
    pPhysVarVsDcaZ[iPhysVar][0] -> SetTicks(fTick, fTick);
    pPhysVarVsDcaZ[iPhysVar][0] -> SetLogx(fLogX);
    pPhysVarVsDcaZ[iPhysVar][0] -> SetLogy(fLogY);
    pPhysVarVsDcaZ[iPhysVar][0] -> SetLogz(fLogZ);
    pPhysVarVsDcaZ[iPhysVar][0] -> SetBorderMode(fMode);
    pPhysVarVsDcaZ[iPhysVar][0] -> SetBorderSize(fBord);
    pPhysVarVsDcaZ[iPhysVar][0] -> SetFrameBorderMode(fFrame);
    pPhysVarVsDcaZ[iPhysVar][0] -> SetLeftMargin(fMarginL);
    pPhysVarVsDcaZ[iPhysVar][0] -> SetRightMargin(fMarginR1);
    pPhysVarVsDcaZ[iPhysVar][0] -> SetTopMargin(fMarginT);
    pPhysVarVsDcaZ[iPhysVar][0] -> SetBottomMargin(fMarginB);
    pPhysVarVsDcaZ[iPhysVar][1] -> SetGrid(fGrid, fGrid);
    pPhysVarVsDcaZ[iPhysVar][1] -> SetTicks(fTick, fTick);
    pPhysVarVsDcaZ[iPhysVar][1] -> SetLogx(fLogX);
    pPhysVarVsDcaZ[iPhysVar][1] -> SetLogy(fLogY);
    pPhysVarVsDcaZ[iPhysVar][1] -> SetLogz(fLogZ);
    pPhysVarVsDcaZ[iPhysVar][1] -> SetBorderMode(fMode);
    pPhysVarVsDcaZ[iPhysVar][1] -> SetBorderSize(fBord);
    pPhysVarVsDcaZ[iPhysVar][1] -> SetFrameBorderMode(fFrame);
    pPhysVarVsDcaZ[iPhysVar][1] -> SetLeftMargin(fMarginL);
    pPhysVarVsDcaZ[iPhysVar][1] -> SetRightMargin(fMarginR2);
    pPhysVarVsDcaZ[iPhysVar][1] -> SetTopMargin(fMarginT);
    pPhysVarVsDcaZ[iPhysVar][1] -> SetBottomMargin(fMarginB);
    cPhysVarVsDcaZ[iPhysVar]    -> cd();
    pPhysVarVsDcaZ[iPhysVar][0] -> Draw();
    pPhysVarVsDcaZ[iPhysVar][1] -> Draw();
    pPhysVarVsDcaZ[iPhysVar][0] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hPhysVar[typesToDraw[iToDraw]][iPhysVar] -> Draw();
      } else {
        hPhysVar[typesToDraw[iToDraw]][iPhysVar] -> Draw("same");
      }
    }  // end to-draw loop
    leg                         -> Draw();
    ptTxt                       -> Draw();
    ptCut                       -> Draw();
    pPhysVarVsDcaZ[iPhysVar][1] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hPhysVarVsDcaZ[typesToDraw[iToDraw]][iPhysVar] -> Draw("colz");
      } else {
        hPhysVarVsDcaZ[typesToDraw[iToDraw]][iPhysVar] -> Draw("scat same");
      }
    }  // end to-draw loop
    cPhysVarVsDcaZ[iPhysVar] -> Write();
    cPhysVarVsDcaZ[iPhysVar] -> Close();

    // 2d physics variables vs. ptreco
    cPhysVarVsPtReco[iPhysVar]    = new TCanvas(sPhysVarVsPtReco[iPhysVar].Data(), "", fWidth2P, fHeight2P);
    pPhysVarVsPtReco[iPhysVar][0] = new TPad(sOneVsTwoDimPanels[0].Data(), "", padXY[0][0], padXY[0][1], padXY[0][2], padXY[0][3]);
    pPhysVarVsPtReco[iPhysVar][1] = new TPad(sOneVsTwoDimPanels[1].Data(), "", padXY[1][0], padXY[1][1], padXY[1][2], padXY[1][3]);
    cPhysVarVsPtReco[iPhysVar]    -> SetGrid(fGrid, fGrid);
    cPhysVarVsPtReco[iPhysVar]    -> SetTicks(fTick, fTick);
    cPhysVarVsPtReco[iPhysVar]    -> SetBorderMode(fMode);
    cPhysVarVsPtReco[iPhysVar]    -> SetBorderSize(fBord);
    pPhysVarVsPtReco[iPhysVar][0] -> SetGrid(fGrid, fGrid);
    pPhysVarVsPtReco[iPhysVar][0] -> SetTicks(fTick, fTick);
    pPhysVarVsPtReco[iPhysVar][0] -> SetLogx(fLogX);
    pPhysVarVsPtReco[iPhysVar][0] -> SetLogy(fLogY);
    pPhysVarVsPtReco[iPhysVar][0] -> SetLogz(fLogZ);
    pPhysVarVsPtReco[iPhysVar][0] -> SetBorderMode(fMode);
    pPhysVarVsPtReco[iPhysVar][0] -> SetBorderSize(fBord);
    pPhysVarVsPtReco[iPhysVar][0] -> SetFrameBorderMode(fFrame);
    pPhysVarVsPtReco[iPhysVar][0] -> SetLeftMargin(fMarginL);
    pPhysVarVsPtReco[iPhysVar][0] -> SetRightMargin(fMarginR1);
    pPhysVarVsPtReco[iPhysVar][0] -> SetTopMargin(fMarginT);
    pPhysVarVsPtReco[iPhysVar][0] -> SetBottomMargin(fMarginB);
    pPhysVarVsPtReco[iPhysVar][1] -> SetGrid(fGrid, fGrid);
    pPhysVarVsPtReco[iPhysVar][1] -> SetTicks(fTick, fTick);
    pPhysVarVsPtReco[iPhysVar][1] -> SetLogx(fLogX);
    pPhysVarVsPtReco[iPhysVar][1] -> SetLogy(fLogY);
    pPhysVarVsPtReco[iPhysVar][1] -> SetLogz(fLogZ);
    pPhysVarVsPtReco[iPhysVar][1] -> SetBorderMode(fMode);
    pPhysVarVsPtReco[iPhysVar][1] -> SetBorderSize(fBord);
    pPhysVarVsPtReco[iPhysVar][1] -> SetFrameBorderMode(fFrame);
    pPhysVarVsPtReco[iPhysVar][1] -> SetLeftMargin(fMarginL);
    pPhysVarVsPtReco[iPhysVar][1] -> SetRightMargin(fMarginR2);
    pPhysVarVsPtReco[iPhysVar][1] -> SetTopMargin(fMarginT);
    pPhysVarVsPtReco[iPhysVar][1] -> SetBottomMargin(fMarginB);
    cPhysVarVsPtReco[iPhysVar]    -> cd();
    pPhysVarVsPtReco[iPhysVar][0] -> Draw();
    pPhysVarVsPtReco[iPhysVar][1] -> Draw();
    pPhysVarVsPtReco[iPhysVar][0] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hPhysVar[typesToDraw[iToDraw]][iPhysVar] -> Draw();
      } else {
        hPhysVar[typesToDraw[iToDraw]][iPhysVar] -> Draw("same");
      }
    }  // end to-draw loop
    leg                           -> Draw();
    ptTxt                         -> Draw();
    ptCut                         -> Draw();
    pPhysVarVsPtReco[iPhysVar][1] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hPhysVarVsPtReco[typesToDraw[iToDraw]][iPhysVar] -> Draw("colz");
      } else {
        hPhysVarVsPtReco[typesToDraw[iToDraw]][iPhysVar] -> Draw("scat same");
      }
    }  // end to-draw loop
    cPhysVarVsPtReco[iPhysVar] -> Write();
    cPhysVarVsPtReco[iPhysVar] -> Close();

    // 2d physics variables vs. pttrue
    cPhysVarVsPtTrue[iPhysVar]    = new TCanvas(sPhysVarVsPtTrue[iPhysVar].Data(), "", fWidth2P, fHeight2P);
    pPhysVarVsPtTrue[iPhysVar][0] = new TPad(sOneVsTwoDimPanels[0].Data(), "", padXY[0][0], padXY[0][1], padXY[0][2], padXY[0][3]);
    pPhysVarVsPtTrue[iPhysVar][1] = new TPad(sOneVsTwoDimPanels[1].Data(), "", padXY[1][0], padXY[1][1], padXY[1][2], padXY[1][3]);
    cPhysVarVsPtTrue[iPhysVar]    -> SetGrid(fGrid, fGrid);
    cPhysVarVsPtTrue[iPhysVar]    -> SetTicks(fTick, fTick);
    cPhysVarVsPtTrue[iPhysVar]    -> SetBorderMode(fMode);
    cPhysVarVsPtTrue[iPhysVar]    -> SetBorderSize(fBord);
    pPhysVarVsPtTrue[iPhysVar][0] -> SetGrid(fGrid, fGrid);
    pPhysVarVsPtTrue[iPhysVar][0] -> SetTicks(fTick, fTick);
    pPhysVarVsPtTrue[iPhysVar][0] -> SetLogx(fLogX);
    pPhysVarVsPtTrue[iPhysVar][0] -> SetLogy(fLogY);
    pPhysVarVsPtTrue[iPhysVar][0] -> SetLogz(fLogZ);
    pPhysVarVsPtTrue[iPhysVar][0] -> SetBorderMode(fMode);
    pPhysVarVsPtTrue[iPhysVar][0] -> SetBorderSize(fBord);
    pPhysVarVsPtTrue[iPhysVar][0] -> SetFrameBorderMode(fFrame);
    pPhysVarVsPtTrue[iPhysVar][0] -> SetLeftMargin(fMarginL);
    pPhysVarVsPtTrue[iPhysVar][0] -> SetRightMargin(fMarginR1);
    pPhysVarVsPtTrue[iPhysVar][0] -> SetTopMargin(fMarginT);
    pPhysVarVsPtTrue[iPhysVar][0] -> SetBottomMargin(fMarginB);
    pPhysVarVsPtTrue[iPhysVar][1] -> SetGrid(fGrid, fGrid);
    pPhysVarVsPtTrue[iPhysVar][1] -> SetTicks(fTick, fTick);
    pPhysVarVsPtTrue[iPhysVar][1] -> SetLogx(fLogX);
    pPhysVarVsPtTrue[iPhysVar][1] -> SetLogy(fLogY);
    pPhysVarVsPtTrue[iPhysVar][1] -> SetLogz(fLogZ);
    pPhysVarVsPtTrue[iPhysVar][1] -> SetBorderMode(fMode);
    pPhysVarVsPtTrue[iPhysVar][1] -> SetBorderSize(fBord);
    pPhysVarVsPtTrue[iPhysVar][1] -> SetFrameBorderMode(fFrame);
    pPhysVarVsPtTrue[iPhysVar][1] -> SetLeftMargin(fMarginL);
    pPhysVarVsPtTrue[iPhysVar][1] -> SetRightMargin(fMarginR2);
    pPhysVarVsPtTrue[iPhysVar][1] -> SetTopMargin(fMarginT);
    pPhysVarVsPtTrue[iPhysVar][1] -> SetBottomMargin(fMarginB);
    cPhysVarVsPtTrue[iPhysVar]    -> cd();
    pPhysVarVsPtTrue[iPhysVar][0] -> Draw();
    pPhysVarVsPtTrue[iPhysVar][1] -> Draw();
    pPhysVarVsPtTrue[iPhysVar][0] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hPhysVar[typesToDraw[iToDraw]][iPhysVar] -> Draw();
      } else {
        hPhysVar[typesToDraw[iToDraw]][iPhysVar] -> Draw("same");
      }
    }  // end to-draw loop
    leg                           -> Draw();
    ptTxt                         -> Draw();
    ptCut                         -> Draw();
    pPhysVarVsPtTrue[iPhysVar][1] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hPhysVarVsPtTrue[typesToDraw[iToDraw]][iPhysVar] -> Draw("colz");
      } else {
        hPhysVarVsPtTrue[typesToDraw[iToDraw]][iPhysVar] -> Draw("scat same");
      }
    }  // end to-draw loop
    cPhysVarVsPtTrue[iPhysVar] -> Write();
    cPhysVarVsPtTrue[iPhysVar] -> Close();

    // 2d physics variables vs. pttrue
    cPhysVarVsPtFrac[iPhysVar]    = new TCanvas(sPhysVarVsPtFrac[iPhysVar].Data(), "", fWidth2P, fHeight2P);
    pPhysVarVsPtFrac[iPhysVar][0] = new TPad(sOneVsTwoDimPanels[0].Data(), "", padXY[0][0], padXY[0][1], padXY[0][2], padXY[0][3]);
    pPhysVarVsPtFrac[iPhysVar][1] = new TPad(sOneVsTwoDimPanels[1].Data(), "", padXY[1][0], padXY[1][1], padXY[1][2], padXY[1][3]);
    cPhysVarVsPtFrac[iPhysVar]    -> SetGrid(fGrid, fGrid);
    cPhysVarVsPtFrac[iPhysVar]    -> SetTicks(fTick, fTick);
    cPhysVarVsPtFrac[iPhysVar]    -> SetBorderMode(fMode);
    cPhysVarVsPtFrac[iPhysVar]    -> SetBorderSize(fBord);
    pPhysVarVsPtFrac[iPhysVar][0] -> SetGrid(fGrid, fGrid);
    pPhysVarVsPtFrac[iPhysVar][0] -> SetTicks(fTick, fTick);
    pPhysVarVsPtFrac[iPhysVar][0] -> SetLogx(fLogX);
    pPhysVarVsPtFrac[iPhysVar][0] -> SetLogy(fLogY);
    pPhysVarVsPtFrac[iPhysVar][0] -> SetLogz(fLogZ);
    pPhysVarVsPtFrac[iPhysVar][0] -> SetBorderMode(fMode);
    pPhysVarVsPtFrac[iPhysVar][0] -> SetBorderSize(fBord);
    pPhysVarVsPtFrac[iPhysVar][0] -> SetFrameBorderMode(fFrame);
    pPhysVarVsPtFrac[iPhysVar][0] -> SetLeftMargin(fMarginL);
    pPhysVarVsPtFrac[iPhysVar][0] -> SetRightMargin(fMarginR1);
    pPhysVarVsPtFrac[iPhysVar][0] -> SetTopMargin(fMarginT);
    pPhysVarVsPtFrac[iPhysVar][0] -> SetBottomMargin(fMarginB);
    pPhysVarVsPtFrac[iPhysVar][1] -> SetGrid(fGrid, fGrid);
    pPhysVarVsPtFrac[iPhysVar][1] -> SetTicks(fTick, fTick);
    pPhysVarVsPtFrac[iPhysVar][1] -> SetLogx(fLogX);
    pPhysVarVsPtFrac[iPhysVar][1] -> SetLogy(fLogY);
    pPhysVarVsPtFrac[iPhysVar][1] -> SetLogz(fLogZ);
    pPhysVarVsPtFrac[iPhysVar][1] -> SetBorderMode(fMode);
    pPhysVarVsPtFrac[iPhysVar][1] -> SetBorderSize(fBord);
    pPhysVarVsPtFrac[iPhysVar][1] -> SetFrameBorderMode(fFrame);
    pPhysVarVsPtFrac[iPhysVar][1] -> SetLeftMargin(fMarginL);
    pPhysVarVsPtFrac[iPhysVar][1] -> SetRightMargin(fMarginR2);
    pPhysVarVsPtFrac[iPhysVar][1] -> SetTopMargin(fMarginT);
    pPhysVarVsPtFrac[iPhysVar][1] -> SetBottomMargin(fMarginB);
    cPhysVarVsPtFrac[iPhysVar]    -> cd();
    pPhysVarVsPtFrac[iPhysVar][0] -> Draw();
    pPhysVarVsPtFrac[iPhysVar][1] -> Draw();
    pPhysVarVsPtFrac[iPhysVar][0] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hPhysVar[typesToDraw[iToDraw]][iPhysVar] -> Draw();
      } else {
        hPhysVar[typesToDraw[iToDraw]][iPhysVar] -> Draw("same");
      }
    }  // end to-draw loop
    leg                           -> Draw();
    ptTxt                         -> Draw();
    ptCut                         -> Draw();
    pPhysVarVsPtFrac[iPhysVar][1] -> cd();
    for (Ssiz_t iToDraw = 0; iToDraw < nToDraw; iToDraw++) {
      if (iToDraw == 0) {
        hPhysVarVsPtFrac[typesToDraw[iToDraw]][iPhysVar] -> Draw("colz");
      } else {
        hPhysVarVsPtFrac[typesToDraw[iToDraw]][iPhysVar] -> Draw("scat same");
      }
    }  // end to-draw loop
    cPhysVarVsPtFrac[iPhysVar] -> Write();
    cPhysVarVsPtFrac[iPhysVar] -> Close();
  }  // end physics variable loop

  // return to top dir
  fOut -> cd();
  return;

}  // end 'ConstructPlots(Ssiz_t, Int_t[], TString, TString)'

// end ------------------------------------------------------------------------
