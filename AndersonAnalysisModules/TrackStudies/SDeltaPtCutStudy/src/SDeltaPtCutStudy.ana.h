// ----------------------------------------------------------------------------
// 'SDeltaPtCutStudy.ana.h'
// Derek Anderson
// 07.07.2023
//
// Reads in the 'ntp_track' Ntuple
// generated by the SVtxEvaluator
// class and studies how deltapt/pt
// varies with quality cuts.
// ----------------------------------------------------------------------------

#pragma once

using namespace std;



// analysis methods -----------------------------------------------------------

void SDeltaPtCutStudy::ApplyFlatDeltaPtCuts() {

  // announce start of track loop
  cout << "      First loop over reco. tracks:" << endl;

  // 1st track loop
  uint64_t nBytesTrk = 0;
  for (uint64_t iTrk = 0; iTrk < nTrks; iTrk++) {

    // grab entry
    const uint64_t bytesTrk = ntTrack -> GetEntry(iTrk);
    if (bytesTrk < 0.) {
      cerr << "WARNING: something wrong with track #" << iTrk << "! Aborting loop!" << endl;
      break;
    }
    nBytesTrk += bytesTrk;

    // announce progress
    const uint64_t iProgTrk = iTrk + 1;
    if (iProgTrk == nTrks) {
      cout << "        Processing track " << iProgTrk << "/" << nTrks << "..." << endl;
    } else {
      cout << "        Processing track " << iProgTrk << "/" << nTrks << "...\r" << flush;
    }

    // do calculations
    const double ptFrac  = trk_pt / trk_gpt;
    const double ptDelta = trk_deltapt / trk_pt;

    // apply trk cuts
    const bool isInZVtxCut = (abs(trk_vz) <  vzTrkMax);
    const bool isInInttCut = (trk_nintt   >= nInttTrkMin);
    const bool isInMVtxCut = (trk_nlmaps  >  nMVtxTrkMin);
    const bool isInTpcCut  = (trk_ntpc    >  nTpcTrkMin);
    const bool isInPtCut   = (trk_pt      >  ptTrkMin);
    const bool isInQualCut = (trk_quality <  qualTrkMax);
    const bool isGoodTrk   = (isInZVtxCut && isInInttCut && isInMVtxCut && isInTpcCut && isInPtCut && isInQualCut);
    if (!isGoodTrk) continue;

    // fill histograms
    hPtDelta        -> Fill(ptDelta);
    hPtTrack        -> Fill(trk_pt);
    hPtFrac         -> Fill(ptFrac);
    hPtTrkTru       -> Fill(trk_gpt);
    hPtDeltaVsFrac  -> Fill(ptFrac,  ptDelta);
    hPtDeltaVsTrue  -> Fill(trk_gpt, ptDelta);
    hPtDeltaVsTrack -> Fill(trk_pt,  ptDelta);
    hPtTrueVsTrack  -> Fill(trk_pt,  trk_gpt);

    // apply delta-pt cuts
    const bool isNormalTrk = ((ptFrac > normRange[0]) && (ptFrac < normRange[1]));
    for (size_t iCut = 0; iCut < nDPtCuts; iCut++) {
      const bool isInDeltaPtCut = (ptDelta < ptDeltaMax[iCut]);
      if (isInDeltaPtCut) {

        // fill histograms
        hPtDeltaCut[iCut]        -> Fill(ptDelta);
        hPtTrackCut[iCut]        -> Fill(trk_pt);
        hPtFracCut[iCut]         -> Fill(ptFrac);
        hPtTrkTruCut[iCut]       -> Fill(trk_gpt);
        hPtDeltaVsFracCut[iCut]  -> Fill(ptFrac,  ptDelta);
        hPtDeltaVsTrueCut[iCut]  -> Fill(trk_gpt, ptDelta);
        hPtDeltaVsTrackCut[iCut] -> Fill(trk_pt,  ptDelta);
        hPtTrueVsTrackCut[iCut]  -> Fill(trk_pt,  trk_gpt);

        // increment counters
        if (isNormalTrk) {
          ++nNormCut[iCut];
        } else {
          ++nWeirdCut[iCut];
        }
      }
    }  // end delta-pt cut
  }  // end 1st track loop

  cout << "      First loop over reco. tracks finished!" << endl;
  return;

}  // end 'ApplyFlatDeltaPtCuts()'



void SDeltaPtCutStudy::ApplyPtDependentDeltaPtCuts() {

  // announce start of track loop
  cout << "      Second loop over reco. tracks:" << endl;

  // 2nd track loop
  uint64_t nBytesTrk = 0;
  for (uint64_t iTrk = 0; iTrk < nTrks; iTrk++) {

    // grab entry
    const uint64_t bytesTrk = ntTrack -> GetEntry(iTrk);
    if (bytesTrk < 0.) {
      cerr << "WARNING: something wrong with track #" << iTrk << "! Aborting loop!" << endl;
      break;
    }
    nBytesTrk += bytesTrk;

    // announce progress
    const uint64_t iProgTrk = iTrk + 1;
    if (iProgTrk == nTrks) {
      cout << "        Processing track " << iProgTrk << "/" << nTrks << "..." << endl;
    } else {
      cout << "        Processing track " << iProgTrk << "/" << nTrks << "...\r" << flush;
    }

    // do calculations
    const double ptFrac  = trk_pt / trk_gpt;
    const double ptDelta = trk_deltapt / trk_pt;

    // apply trk cuts
    const bool isInZVtxCut = (abs(trk_vz) <  vzTrkMax);
    const bool isInInttCut = (trk_nintt   >= nInttTrkMin);
    const bool isInMVtxCut = (trk_nlmaps  >  nMVtxTrkMin);
    const bool isInTpcCut  = (trk_ntpc    >  nTpcTrkMin);
    const bool isInPtCut   = (trk_pt      >  ptTrkMin);
    const bool isInQualCut = (trk_quality <  qualTrkMax);
    const bool isGoodTrk   = (isInZVtxCut && isInInttCut && isInMVtxCut && isInTpcCut && isInPtCut && isInQualCut);
    if (!isGoodTrk) continue;

    // apply delta-pt cuts
    const bool isNormalTrk = ((ptFrac > normRange[0]) && (ptFrac < normRange[1]));
    for (size_t iSig = 0; iSig < nSigCuts; iSig++) {

      // get bounds
      const float ptDeltaMin = fMuLoProj[iSig] -> Eval(trk_pt);
      const float ptDeltaMax = fMuHiProj[iSig] -> Eval(trk_pt);

      const bool isInDeltaPtSigma = ((ptDelta >= ptDeltaMin) && (ptDelta <= ptDeltaMax));
      if (isInDeltaPtSigma) {

        // fill histograms
        hPtDeltaSig[iSig]        -> Fill(ptDelta);
        hPtTrackSig[iSig]        -> Fill(trk_pt);
        hPtFracSig[iSig]         -> Fill(ptFrac);
        hPtTrkTruSig[iSig]       -> Fill(trk_gpt);
        hPtDeltaVsFracSig[iSig]  -> Fill(ptFrac,  ptDelta);
        hPtDeltaVsTrueSig[iSig]  -> Fill(trk_gpt, ptDelta);
        hPtDeltaVsTrackSig[iSig] -> Fill(trk_pt,  ptDelta);
        hPtTrueVsTrackSig[iSig]  -> Fill(trk_pt,  trk_gpt);

        // increment counters
        if (isNormalTrk) {
          ++nNormSig[iSig];
        } else {
          ++nWeirdSig[iSig];
        }
      }
    }  // end delta-pt cut
  }  // end 1st track loop

  cout << "      Second loop over reco. tracks finished!" << endl;
  return;

}  // end 'ApplyPtDependentDeltaptCuts()'



void SDeltaPtCutStudy::FillTruthHistograms() {

  // announce start of truth loop
  cout << "      Loop over particles:" << endl;

  // truth loop
  uint64_t nBytesTru = 0;
  for (uint64_t iTru = 0; iTru < nTrus; iTru++) {

    // grab entry
    const uint64_t bytesTru = ntTruth -> GetEntry(iTru);
    if (bytesTru < 0.) {
      cerr << "WARNING: something wrong with particle #" << iTru << "! Aborting loop!" << endl;
      break;
    }
    nBytesTru += bytesTru;

    // announce progress
    const uint64_t iProgTru = iTru + 1;
    if (iProgTru == nTrus) {
      cout << "        Processing particle " << iProgTru << "/" << nTrus << "..." << endl;
    } else {
      cout << "        Processing particle " << iProgTru << "/" << nTrus << "...\r" << flush;
    }

    // fill truth histogram
    const bool isPrimary = (tru_gprimary == 1);
    if (isPrimary) {
      hPtTruth -> Fill(tru_gpt);
    }
  }  // end track loop
  cout << "      Loop over particles finished!" << endl;

}  // end 'FillTruthHistograms()'



void SDeltaPtCutStudy::CreateSigmaGraphs() {

  // for graph names
  const TString sMuHiBase = "MeanPlusSigma";
  const TString sMuLoBase = "MeanMinusSigma";
  const TString sSigBase  = "ProjectionSigma";
  const TString sMuBase   = "ProjectionMean";

  // projection fit names
  vector<TString> sFitProj(nProj);
  for (size_t iProj = 0; iProj < nProj; iProj++) {
    sFitProj[iProj] = "f";
    sFitProj[iProj].Append(sPtProjBase.Data());
    sFitProj[iProj].Append(sProjSuffix[iProj].Data());
  }

  // project slices of delta-pt and get sigmas
  const uint32_t fWidFit = 2;
  const uint32_t fLinFit = 1;
  for (size_t iProj = 0; iProj < nProj; iProj++) {

    // do projection
    const uint32_t iBinProj = hPtDeltaVsTrack -> GetXaxis() -> FindBin(ptProj[iProj]);
    hPtDeltaProj[iProj]   = hPtDeltaVsTrack -> ProjectionY(sPtProj[iProj], iBinProj, iBinProj, "");

    // get initial values for fit
    const float ampGuess = hPtDeltaProj[iProj] -> GetMaximum();
    const float muGuess  = hPtDeltaProj[iProj] -> GetMean();
    const float sigGuess = hPtDeltaProj[iProj] -> GetRMS();

    // fit with gaussian
    fPtDeltaProj[iProj] = new TF1(sFitProj[iProj].Data(), "gaus", deltaFitRange[0], deltaFitRange[1]);
    fPtDeltaProj[iProj] -> SetLineColor(fColFit[iProj]);
    fPtDeltaProj[iProj] -> SetLineStyle(fLinFit);
    fPtDeltaProj[iProj] -> SetLineWidth(fWidFit);
    fPtDeltaProj[iProj] -> SetParameter(0, ampGuess);
    fPtDeltaProj[iProj] -> SetParameter(1, muGuess);
    fPtDeltaProj[iProj] -> SetParameter(2, sigGuess);
    hPtDeltaProj[iProj] -> Fit(sFitProj[iProj].Data(), "R");

    // add values to arrays
    muProj[iProj]  = fPtDeltaProj[iProj] -> GetParameter(1);
    sigProj[iProj] = fPtDeltaProj[iProj] -> GetParameter(2);
    for (size_t iSig = 0; iSig < nSigCuts; iSig++) {
      muHiProj[iSig][iProj] = muProj[iProj] + (ptDeltaSig[iSig] * sigProj[iProj]);
      muLoProj[iSig][iProj] = muProj[iProj] - (ptDeltaSig[iSig] * sigProj[iProj]);
    }
  }  // end projection loop
  cout << "      Obtained delta-pt projections, fits, and sigmas." << endl;

  // sigma graph names
  TString sMuProj("gr");
  TString sSigProj("gr");
  sMuProj.Append(sMuBase.Data());
  sSigProj.Append(sSigBase.Data());

  vector<TString> sGrMuHiProj(nSigCuts);
  vector<TString> sGrMuLoProj(nSigCuts);
  vector<TString> sFnMuHiProj(nSigCuts);
  vector<TString> sFnMuLoProj(nSigCuts);
  for (size_t iSig = 0; iSig < nSigCuts; iSig++) {
    sGrMuHiProj[iSig] = "gr";
    sGrMuLoProj[iSig] = "gr";
    sFnMuHiProj[iSig] = "f";
    sFnMuLoProj[iSig] = "f";
    sGrMuHiProj[iSig].Append(sMuHiBase.Data());
    sGrMuLoProj[iSig].Append(sMuLoBase.Data());
    sFnMuHiProj[iSig].Append(sMuHiBase.Data());
    sFnMuLoProj[iSig].Append(sMuLoBase.Data());
    sGrMuHiProj[iSig].Append(sSigSuffix[iSig].Data());
    sGrMuLoProj[iSig].Append(sSigSuffix[iSig].Data());
    sFnMuHiProj[iSig].Append(sSigSuffix[iSig].Data());
    sFnMuLoProj[iSig].Append(sSigSuffix[iSig].Data());
  }

  // turn std::vectors into TVectors
  TVectorD tvecPtProj(ptProj.size(), ptProj.data());
  TVectorD tvecMuProj(muProj.size(), muProj.data());
  TVectorD tvecSigProj(sigProj.size(), sigProj.data());

  vector<TVectorD> tvecMuHiProj;
  vector<TVectorD> tvecMuLoProj;
  for (size_t iSig = 0; iSig < nSigCuts; iSig++) {
    tvecMuHiProj.push_back(TVectorD(muHiProj[iSig].size(), muHiProj[iSig].data()));
    tvecMuLoProj.push_back(TVectorD(muLoProj[iSig].size(), muLoProj[iSig].data()));
  }

  // construct sigma graphs
  grMuProj  = new TGraph(tvecPtProj, tvecMuProj);
  grSigProj = new TGraph(tvecPtProj, tvecSigProj);
  grMuProj  -> SetName(sMuProj);
  grSigProj -> SetName(sSigProj);

  // fit sigma graphs
  for (size_t iSig = 0; iSig < nSigCuts; iSig++) {

    // create graphs
    grMuHiProj[iSig] = new TGraph(tvecPtProj, tvecMuHiProj[iSig]);
    grMuLoProj[iSig] = new TGraph(tvecPtProj, tvecMuLoProj[iSig]);
    grMuHiProj[iSig] -> SetName(sGrMuHiProj[iSig].Data());
    grMuLoProj[iSig] -> SetName(sGrMuLoProj[iSig].Data());

    // create fit functions
    fMuHiProj[iSig] = new TF1(sFnMuHiProj[iSig].Data(), "pol2", rPtRange[0], rPtRange[1]);
    fMuLoProj[iSig] = new TF1(sFnMuLoProj[iSig].Data(), "pol2", rPtRange[0], rPtRange[1]);
    fMuHiProj[iSig] -> SetLineColor(fColSigFit[iSig]);
    fMuLoProj[iSig] -> SetLineColor(fColSigFit[iSig]);
    fMuHiProj[iSig] -> SetLineStyle(fLinFit);
    fMuLoProj[iSig] -> SetLineStyle(fLinFit);
    fMuHiProj[iSig] -> SetLineWidth(fWidFit);
    fMuLoProj[iSig] -> SetLineWidth(fWidFit);
    fMuHiProj[iSig] -> SetParameter(0, sigHiGuess[0]);
    fMuLoProj[iSig] -> SetParameter(0, sigLoGuess[0]);
    fMuHiProj[iSig] -> SetParameter(1, sigHiGuess[1]);
    fMuLoProj[iSig] -> SetParameter(1, sigLoGuess[1]);
    fMuHiProj[iSig] -> SetParameter(2, sigHiGuess[2]);
    fMuLoProj[iSig] -> SetParameter(2, sigLoGuess[2]);

    // do fitting
    grMuHiProj[iSig] -> Fit(sFnMuHiProj[iSig].Data(), "", "", ptFitRange[0], ptFitRange[1]);
    grMuLoProj[iSig] -> Fit(sFnMuLoProj[iSig].Data(), "", "", ptFitRange[0], ptFitRange[1]);
  }

  cout << "      Created and fit sigma graphs."  << endl;
  return;

}  // end 'CreateSigmaGraphs()'



void SDeltaPtCutStudy::CalculateRejectionFactors() {

  // for graph names
  const TString sRejCutBase = "Reject_flatDPtCut";
  const TString sRejSigBase = "Reject_sigmaCut";

  // calculate flat delta-pt rejection factors
  for (size_t iCut = 0; iCut < nDPtCuts; iCut++) {
    rejCut[iCut] = (double) nNormCut[iCut] / (double) nWeirdCut[iCut];
  }
  cout << "      Calculated flat delta-pt rejection factors." << endl;

  // calculate pt-dependent delta-pt rejection factors
  for (size_t iSig = 0; iSig < nSigCuts; iSig++) {
    rejSig[iSig] = (double) nNormSig[iSig] / (double) nWeirdSig[iSig];
  }
  cout << "      Calculated pt-depdendent delta-pt rejection factors\n"
       << "      Rejection factors:\n"
       << "        Flat delta-pt cuts"
       << endl;

  // announce flat delta-pt rejection factors
  for (size_t iCut = 0; iCut < nDPtCuts; iCut++) {
    cout << "          n(Norm, Weird) = (" << nNormCut[iCut] << ", " << nWeirdCut[iCut] << "), rejection = " << rejCut[iCut] << endl;
  }

  // announce pt-dependent delta-pt rejection factors
  cout << "        Pt-dependent delta-pt cuts" << endl;
  for (size_t iSig = 0; iSig < nSigCuts; iSig++) {
    cout << "          n(Norm, Weird) = (" << nNormSig[iSig] << ", " << nWeirdSig[iSig] << "), rejection = " << rejSig[iSig] << endl;
  }

  // graph names
  TString sRejCut("gr");
  TString sRejSig("gr");
  sRejCut.Append(sRejCutBase.Data());
  sRejSig.Append(sRejSigBase.Data());

  // convert vectors to TVectors
  TVectorD tvecPtDeltaMax(ptDeltaMax.size(), ptDeltaMax.data());
  TVectorD tvecPtDeltaSig(ptDeltaSig.size(), ptDeltaSig.data());
  TVectorD tvecRejCut(rejCut.size(), rejCut.data());
  TVectorD tvecRejSig(rejSig.size(), rejSig.data());

  // make rejection graphs
  grRejCut = new TGraph(tvecPtDeltaMax, tvecRejCut);
  grRejSig = new TGraph(tvecPtDeltaSig, tvecRejSig);
  grRejCut -> SetName(sRejCut.Data());
  grRejSig -> SetName(sRejSig.Data());

  cout << "      Made rejection factor graph." << endl; 
  return;

}  // end 'CalculateRejectionFactors()'



void SDeltaPtCutStudy::CalculateEfficiencies() {

  // for histogram names
  const TString sEffBase = "Efficiency";

  // rebin histograms if needed
  if (doEffRebin) {
    hPtTruth  -> Rebin(nEffRebin);
    hPtTrkTru -> Rebin(nEffRebin);
    for (size_t iCut = 0; iCut < nDPtCuts; iCut++) {
      hPtTrkTruCut[iCut] -> Rebin(nEffRebin);
    }
    for (size_t iSig = 0; iSig < nSigCuts; iSig++) {
      hPtTrkTruSig[iSig] -> Rebin(nEffRebin);
    }
    cout << "      Rebinned efficiency histograms." << endl;
  }

  TString sEff("h");
  sEff.Append(sEffBase.Data());

  // create flat delta-pt cut efficiency names
  vector<TString> sEffCut(nDPtCuts);
  for (size_t iCut = 0; iCut < nDPtCuts; iCut++) {
    sEffCut[iCut] = "h";
    sEffCut[iCut].Append(sEffBase.Data());
    sEffCut[iCut].Append(sDPtSuffix[iCut].Data());
  }

  // create pt-dependent delta-pt cut efficiency names
  vector<TString> sEffSig(nSigCuts);
  for (size_t iSig = 0; iSig < nSigCuts; iSig++) {
    sEffSig[iSig] = "h";
    sEffSig[iSig].Append(sEffBase.Data());
    sEffSig[iSig].Append(sSigSuffix[iSig].Data());
  }

  hEff = (TH1D*) hPtTruth -> Clone();
  hEff -> SetName(sEff.Data());
  hEff -> Reset("ICES");
  hEff -> Divide(hPtTrkTru, hPtTruth, 1., 1.);

  // calculate flat delta-pt cut efficiencies
  for (size_t iCut = 0; iCut < nDPtCuts; iCut++) {
    hEffCut[iCut] = (TH1D*) hPtTruth -> Clone();
    hEffCut[iCut] -> SetName(sEffCut[iCut].Data());
    hEffCut[iCut] -> Reset("ICES");
    hEffCut[iCut] -> Divide(hPtTrkTruCut[iCut], hPtTruth, 1., 1.);
  }

  // calculate pt-dependent delta-pt cut efficiencies
  for (size_t iSig = 0; iSig < nSigCuts; iSig++) {
    hEffSig[iSig] = (TH1D*) hPtTruth -> Clone();
    hEffSig[iSig] -> SetName(sEffSig[iSig].Data());
    hEffSig[iSig] -> Reset("ICES");
    hEffSig[iSig] -> Divide(hPtTrkTruSig[iSig], hPtTruth, 1., 1.);
  }

  cout << "      Calculated efficiencies." << endl;
  return;

}  // end 'CalculateEfficiencies()'

// end ------------------------------------------------------------------------
