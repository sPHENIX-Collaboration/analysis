// -- utils
#include "myUtils.C"

// ====================================================================
// sPHENIX Includes
// ====================================================================
#include <calobase/TowerInfoDefs.h>
// CDB
#include <cdbobjects/CDBTTree.h>
#include <CDBUtils.C>

// ====================================================================
// Standard C++ Includes
// ====================================================================
#include <filesystem>
#include <format>
#include <fstream>
#include <iostream>
#include <map>
#include <memory>
#include <numbers>
#include <random>
#include <stdexcept>
#include <string>
#include <unordered_set>
#include <vector>

// ====================================================================
// ROOT Includes
// ====================================================================
#include <TChain.h>
#include <TFile.h>
#include <TH1.h>
#include <TH2.h>
#include <TH3.h>
#include <TProfile.h>
#include <TProfile2D.h>
#include <TROOT.h>
#include <TTree.h>

// ====================================================================
// The Analysis Class
// ====================================================================
class JetAnalysis
{
 public:
  // The constructor takes the configuration
  JetAnalysis(std::string input_file, std::string input_Q_calib, unsigned int runnumber, int q_vec_ana, long long events, std::string output_dir)
    : m_input_file(std::move(input_file))
    , m_input_Q_calib(std::move(input_Q_calib))
    , m_runnumber(runnumber)
    , m_QVecAna(static_cast<myUtils::QVecAna>(q_vec_ana))
    , m_events_to_process(events)
    , m_output_dir(std::move(output_dir))
  {
  }

  void run()
  {
    setup_chain();
    read_Q_calib();
    process_dead_channels();
    init_hists();
    process_events();
    save_results();
  }

  void set_jet_pt_min(double jet_pt_min)
  {
    m_jet_pt_min = jet_pt_min;
  }

  void set_jet_eta_max(double jet_eta_max)
  {
    m_jet_eta_max = jet_eta_max;
  }

 private:
  enum class Subdetector
  {
    S,
    N
  };

  enum class QComponent
  {
    X,
    Y
  };

  struct QVec
  {
    double x{0.0};
    double y{0.0};
  };

  struct CorrectionData
  {
    // Averages of Qx, Qy, Qx^2, Qy^2, Qxy
    QVec avg_Q{};
    double avg_Q_xx{0.0};
    double avg_Q_yy{0.0};
    double avg_Q_xy{0.0};

    // Correction matrix
    std::array<std::array<double, 2>, 2> X_matrix{};
  };

  struct JetInfo
  {
    double pt{0};
    double phi{0};
    double eta{0};
  };

  static constexpr size_t m_bins_cent = 8;
  static constexpr double m_cent_low = -0.5;
  static constexpr double m_cent_high = 79.5;

  // Holds all correction data
  // key: [Cent][Harmonic][Subdetector]
  // Harmonics {2,3,4} -> 3 elements
  // Subdetectors {S,N} -> 2 elements
  std::array<std::array<std::array<CorrectionData, 2>, 3>, m_bins_cent> m_correction_data;

  // Store harmonic orders and subdetectors for easy iteration
  static constexpr std::array<int, 3> m_harmonics = {2, 3, 4};
  static constexpr std::array<Subdetector, 2> m_subdetectors = {Subdetector::S, Subdetector::N};
  static constexpr std::array<QComponent, 2> m_components = {QComponent::X, QComponent::Y};

  // Min Jet pT [GeV]
  static constexpr std::array<int, 7> m_jet_pt_min_vec = {7, 10, 12, 14, 16, 18, 20};

  struct AnalysisHists
  {
    TH2* h2Dummy{nullptr};
    TH2* h2EMCalBadTowersDeadv2{nullptr};
    TH3* h3JetPhiEtaPt{nullptr};
    TH3* h3JetPhiEtaPtv2{nullptr};
    TH2* h2Event{nullptr};
    TH2* h2Jet{nullptr};
    TH1* hCentrality{nullptr};
    std::array<TH3*, 3> hPsi{nullptr};

    // Histograms for SP method
    // [harmonic_index]
    std::array<TH3*, 3> h3SP_re;
    std::array<TH3*, 3> h3SP_im;
    std::array<TH3*, 3> h3SP_res;

    // Profiles
    std::array<TProfile2D*, 3> p2SP_re{nullptr};
    std::array<TProfile2D*, 3> p2SP_im{nullptr};
    std::array<TProfile2D*, 3> p2SP_res{nullptr};
    std::array<TProfile*, 3> p1SP_res{nullptr};
    std::array<TProfile*, 3> p1SP_evt_res{nullptr};  // Event Plane Resolution Squared
    std::array<std::array<TProfile*, m_jet_pt_min_vec.size()>, 3> p1SP_re{nullptr};
    std::array<std::array<TProfile*, m_jet_pt_min_vec.size()>, 3> p1SP_re_anti{nullptr};

    // Q Vector - Crosschecks
    std::array<TProfile*, 3> S_x_raw_avg{nullptr};
    std::array<TProfile*, 3> S_y_raw_avg{nullptr};
    std::array<TProfile*, 3> N_x_raw_avg{nullptr};
    std::array<TProfile*, 3> N_y_raw_avg{nullptr};

    std::array<TProfile*, 3> S_x_corr_avg{nullptr};
    std::array<TProfile*, 3> S_y_corr_avg{nullptr};
    std::array<TProfile*, 3> N_x_corr_avg{nullptr};
    std::array<TProfile*, 3> N_y_corr_avg{nullptr};

    std::array<TProfile*, 3> S_xx_raw_avg{nullptr};
    std::array<TProfile*, 3> S_yy_raw_avg{nullptr};
    std::array<TProfile*, 3> S_xy_raw_avg{nullptr};

    std::array<TProfile*, 3> N_xx_raw_avg{nullptr};
    std::array<TProfile*, 3> N_yy_raw_avg{nullptr};
    std::array<TProfile*, 3> N_xy_raw_avg{nullptr};

    std::array<TProfile*, 3> S_xx_corr_avg{nullptr};
    std::array<TProfile*, 3> S_yy_corr_avg{nullptr};
    std::array<TProfile*, 3> S_xy_corr_avg{nullptr};

    std::array<TProfile*, 3> N_xx_corr_avg{nullptr};
    std::array<TProfile*, 3> N_yy_corr_avg{nullptr};
    std::array<TProfile*, 3> N_xy_corr_avg{nullptr};
  };

  AnalysisHists m_hists;

  struct EventData
  {
    int event_id{0};
    double event_zvertex{0.0};
    double event_centrality{0.0};

    std::vector<double>* jet_pt{nullptr};
    std::vector<double>* jet_phi{nullptr};
    std::vector<double>* jet_eta{nullptr};

    std::vector<int>* sepd_channel{nullptr};
    std::vector<double>* sepd_charge{nullptr};
    std::vector<double>* sepd_phi{nullptr};

    // Array for harmonics [2, 3, 4] -> indices [0, 1, 2]
    // Array for subdetectors [S, N] -> indices [0, 1]
    std::array<std::array<QVec, 2>, 3> q_vectors;

    void reset()
    {
      for (auto& q_vec_harmonic : q_vectors)
      {
        for (auto& q_vec : q_vec_harmonic)
        {
          q_vec.x = 0.0;
          q_vec.y = 0.0;
        }
      }
    }
  };

  // --- Member Variables ---
  EventData m_event_data;
  std::unique_ptr<TChain> m_chain;

  // Configuration stored as members
  std::string m_input_file;
  std::string m_input_Q_calib;
  unsigned int m_runnumber;
  myUtils::QVecAna m_QVecAna{0};
  long long m_events_to_process;
  std::string m_output_dir;
  std::string m_dbtag{"newcdbtag"};
  int m_bins_sample{25};

  // sEPD Bad Channels
  std::unordered_set<int> m_bad_channels;
  std::unordered_set<int> m_rbins_skipped;

  // Jet Cuts
  double m_jet_pt_min{7}; /*GeV*/
  double m_jet_eta_max{0.9};

  // Hists
  std::map<std::string, std::unique_ptr<TH1>> m_hists1D;
  std::map<std::string, std::unique_ptr<TH2>> m_hists2D;
  std::map<std::string, std::unique_ptr<TH3>> m_hists3D;
  std::map<std::string, std::unique_ptr<TProfile>> m_profiles;
  std::map<std::string, std::unique_ptr<TProfile2D>> m_profiles2D;

  // --- Private Helper Methods ---
  void setup_chain();

  void load_correction_data(TFile* file);
  void read_Q_calib();

  void process_dead_channels();

  void create_vn_histograms(int n);
  void init_hists();

  void compute_SP_resolution(int sample);
  void compute_SP(int sample);
  std::vector<JetInfo> process_jets();
  void correct_QVecs();
  bool compute_QVecs();
  bool process_QVecs();
  void process_events();

  void save_results() const;
};

// ====================================================================
// Implementation of the Class Methods
// ====================================================================
void JetAnalysis::setup_chain()
{
  std::cout << "Processing... setup_chain" << std::endl;

  m_chain = myUtils::setupTChain(m_input_file, "T");

  if (m_chain == nullptr)
  {
    throw std::runtime_error(std::format("Error in TChain Setup from file: {}", m_input_file));
  }

  // Setup branches
  m_chain->SetBranchStatus("*", false);
  m_chain->SetBranchStatus("event_id", true);
  m_chain->SetBranchStatus("event_centrality", true);
  m_chain->SetBranchStatus("jet_phi", true);
  m_chain->SetBranchStatus("jet_eta", true);
  m_chain->SetBranchStatus("jet_pt", true);
  m_chain->SetBranchStatus("sepd_channel", true);
  m_chain->SetBranchStatus("sepd_charge", true);
  m_chain->SetBranchStatus("sepd_phi", true);

  m_chain->SetBranchAddress("event_id", &m_event_data.event_id);
  m_chain->SetBranchAddress("event_centrality", &m_event_data.event_centrality);
  m_chain->SetBranchAddress("jet_pt", &m_event_data.jet_pt);
  m_chain->SetBranchAddress("jet_phi", &m_event_data.jet_phi);
  m_chain->SetBranchAddress("jet_eta", &m_event_data.jet_eta);
  m_chain->SetBranchAddress("sepd_channel", &m_event_data.sepd_channel);
  m_chain->SetBranchAddress("sepd_charge", &m_event_data.sepd_charge);
  m_chain->SetBranchAddress("sepd_phi", &m_event_data.sepd_phi);

  std::cout << "Finished... setup_chain" << std::endl;
}

void JetAnalysis::load_correction_data(TFile* file)
{
  for (size_t n_idx = 0; n_idx < m_harmonics.size(); ++n_idx)
  {
    int n = m_harmonics[n_idx];

    std::string S_x_avg_name = std::format("h_sEPD_Q_S_x_{}_avg", n);
    std::string S_y_avg_name = std::format("h_sEPD_Q_S_y_{}_avg", n);
    std::string N_x_avg_name = std::format("h_sEPD_Q_N_x_{}_avg", n);
    std::string N_y_avg_name = std::format("h_sEPD_Q_N_y_{}_avg", n);

    auto* h_sEPD_Q_S_x_avg = dynamic_cast<TProfile*>(file->Get(S_x_avg_name.c_str()));
    auto* h_sEPD_Q_S_y_avg = dynamic_cast<TProfile*>(file->Get(S_y_avg_name.c_str()));
    auto* h_sEPD_Q_N_x_avg = dynamic_cast<TProfile*>(file->Get(N_x_avg_name.c_str()));
    auto* h_sEPD_Q_N_y_avg = dynamic_cast<TProfile*>(file->Get(N_y_avg_name.c_str()));

    if (!h_sEPD_Q_S_x_avg)
    {
      throw std::runtime_error(std::format("Could not find histogram '{}' in file '{}'", S_x_avg_name, m_input_Q_calib));
    }
    if (!h_sEPD_Q_S_y_avg)
    {
      throw std::runtime_error(std::format("Could not find histogram '{}' in file '{}'", S_y_avg_name, m_input_Q_calib));
    }
    if (!h_sEPD_Q_N_x_avg)
    {
      throw std::runtime_error(std::format("Could not find histogram '{}' in file '{}'", N_x_avg_name, m_input_Q_calib));
    }
    if (!h_sEPD_Q_N_y_avg)
    {
      throw std::runtime_error(std::format("Could not find histogram '{}' in file '{}'", N_y_avg_name, m_input_Q_calib));
    }

    std::string S_xx_avg_name = std::format("h_sEPD_Q_S_xx_{}_avg", n);
    std::string S_yy_avg_name = std::format("h_sEPD_Q_S_yy_{}_avg", n);
    std::string S_xy_avg_name = std::format("h_sEPD_Q_S_xy_{}_avg", n);
    std::string N_xx_avg_name = std::format("h_sEPD_Q_N_xx_{}_avg", n);
    std::string N_yy_avg_name = std::format("h_sEPD_Q_N_yy_{}_avg", n);
    std::string N_xy_avg_name = std::format("h_sEPD_Q_N_xy_{}_avg", n);

    auto* h_sEPD_Q_S_xx_avg = dynamic_cast<TProfile*>(file->Get(S_xx_avg_name.c_str()));
    auto* h_sEPD_Q_S_yy_avg = dynamic_cast<TProfile*>(file->Get(S_yy_avg_name.c_str()));
    auto* h_sEPD_Q_S_xy_avg = dynamic_cast<TProfile*>(file->Get(S_xy_avg_name.c_str()));
    auto* h_sEPD_Q_N_xx_avg = dynamic_cast<TProfile*>(file->Get(N_xx_avg_name.c_str()));
    auto* h_sEPD_Q_N_yy_avg = dynamic_cast<TProfile*>(file->Get(N_yy_avg_name.c_str()));
    auto* h_sEPD_Q_N_xy_avg = dynamic_cast<TProfile*>(file->Get(N_xy_avg_name.c_str()));

    if (!h_sEPD_Q_S_xx_avg)
    {
      throw std::runtime_error(std::format("Could not find histogram '{}' in file '{}'", S_xx_avg_name, m_input_Q_calib));
    }
    if (!h_sEPD_Q_S_yy_avg)
    {
      throw std::runtime_error(std::format("Could not find histogram '{}' in file '{}'", S_yy_avg_name, m_input_Q_calib));
    }
    if (!h_sEPD_Q_S_xy_avg)
    {
      throw std::runtime_error(std::format("Could not find histogram '{}' in file '{}'", S_xy_avg_name, m_input_Q_calib));
    }
    if (!h_sEPD_Q_N_xx_avg)
    {
      throw std::runtime_error(std::format("Could not find histogram '{}' in file '{}'", N_xx_avg_name, m_input_Q_calib));
    }
    if (!h_sEPD_Q_N_yy_avg)
    {
      throw std::runtime_error(std::format("Could not find histogram '{}' in file '{}'", N_yy_avg_name, m_input_Q_calib));
    }
    if (!h_sEPD_Q_N_xy_avg)
    {
      throw std::runtime_error(std::format("Could not find histogram '{}' in file '{}'", N_xy_avg_name, m_input_Q_calib));
    }

    size_t south_idx = static_cast<size_t>(Subdetector::S);
    size_t north_idx = static_cast<size_t>(Subdetector::N);

    for (size_t cent_bin = 0; cent_bin < m_bins_cent; ++cent_bin)
    {
      int bin = static_cast<int>(cent_bin) + 1;

      double Q_S_x_avg = h_sEPD_Q_S_x_avg->GetBinContent(bin);
      double Q_S_y_avg = h_sEPD_Q_S_y_avg->GetBinContent(bin);
      double Q_N_x_avg = h_sEPD_Q_N_x_avg->GetBinContent(bin);
      double Q_N_y_avg = h_sEPD_Q_N_y_avg->GetBinContent(bin);

      double Q_S_xx_avg = h_sEPD_Q_S_xx_avg->GetBinContent(bin);
      double Q_S_yy_avg = h_sEPD_Q_S_yy_avg->GetBinContent(bin);
      double Q_S_xy_avg = h_sEPD_Q_S_xy_avg->GetBinContent(bin);
      double Q_N_xx_avg = h_sEPD_Q_N_xx_avg->GetBinContent(bin);
      double Q_N_yy_avg = h_sEPD_Q_N_yy_avg->GetBinContent(bin);
      double Q_N_xy_avg = h_sEPD_Q_N_xy_avg->GetBinContent(bin);

      // Recentering Params
      m_correction_data[cent_bin][n_idx][south_idx].avg_Q = {Q_S_x_avg, Q_S_y_avg};
      m_correction_data[cent_bin][n_idx][north_idx].avg_Q = {Q_N_x_avg, Q_N_y_avg};

      // Flattening Params
      m_correction_data[cent_bin][n_idx][south_idx].avg_Q_xx = Q_S_xx_avg;
      m_correction_data[cent_bin][n_idx][south_idx].avg_Q_yy = Q_S_yy_avg;
      m_correction_data[cent_bin][n_idx][south_idx].avg_Q_xy = Q_S_xy_avg;

      m_correction_data[cent_bin][n_idx][north_idx].avg_Q_xx = Q_N_xx_avg;
      m_correction_data[cent_bin][n_idx][north_idx].avg_Q_yy = Q_N_yy_avg;
      m_correction_data[cent_bin][n_idx][north_idx].avg_Q_xy = Q_N_xy_avg;

      // ----
      // South
      // ----

      double D_term_S_arg = (Q_S_xx_avg * Q_S_yy_avg) - (Q_S_xy_avg * Q_S_xy_avg);
      if (D_term_S_arg <= 0)
      {
        throw std::runtime_error(std::format(
            "Invalid calibration data: D-term sqrt argument is non-positive ({}) "
            "for harmonic n={}, centrality bin {}, subdetector S. "
            "Check calibration file statistics.",
            D_term_S_arg, n, cent_bin));
      }
      double D_term_S = std::sqrt(D_term_S_arg);

      double N_term_S = D_term_S * (Q_S_xx_avg + Q_S_yy_avg + (2 * D_term_S));
      if (N_term_S <= 0)
      {
        throw std::runtime_error(std::format(
            "Invalid calibration data: N-term denominator sqrt argument is non-positive ({}) "
            "for harmonic n={}, centrality bin {}, subdetector S. "
            "Check calibration file statistics.",
            N_term_S, n, cent_bin));
      }

      auto& X_S_matrix = m_correction_data[cent_bin][n_idx][south_idx].X_matrix;
      X_S_matrix[0][0] = (1. / std::sqrt(N_term_S)) * (Q_S_yy_avg + D_term_S);
      X_S_matrix[0][1] = (-1. / std::sqrt(N_term_S)) * Q_S_xy_avg;
      X_S_matrix[1][0] = X_S_matrix[0][1];
      X_S_matrix[1][1] = (1. / std::sqrt(N_term_S)) * (Q_S_xx_avg + D_term_S);

      // ----
      // North
      // ----

      double D_term_N_arg = (Q_N_xx_avg * Q_N_yy_avg) - (Q_N_xy_avg * Q_N_xy_avg);
      if (D_term_N_arg <= 0)
      {
        throw std::runtime_error(std::format(
            "Invalid calibration data: D-term sqrt argument is non-positive ({}) "
            "for harmonic n={}, centrality bin {}, subdetector N. "
            "Check calibration file statistics.",
            D_term_N_arg, n, cent_bin));
      }
      double D_term_N = std::sqrt(D_term_N_arg);

      double N_term_N = D_term_N * (Q_N_xx_avg + Q_N_yy_avg + (2 * D_term_N));
      if (N_term_N <= 0)
      {
        throw std::runtime_error(std::format(
            "Invalid calibration data: N-term denominator sqrt argument is non-positive ({}) "
            "for harmonic n={}, centrality bin {}, subdetector N. "
            "Check calibration file statistics.",
            N_term_N, n, cent_bin));
      }

      auto& X_N_matrix = m_correction_data[cent_bin][n_idx][north_idx].X_matrix;
      X_N_matrix[0][0] = (1. / std::sqrt(N_term_N)) * (Q_N_yy_avg + D_term_N);
      X_N_matrix[0][1] = (-1. / std::sqrt(N_term_N)) * Q_N_xy_avg;
      X_N_matrix[1][0] = X_N_matrix[0][1];
      X_N_matrix[1][1] = (1. / std::sqrt(N_term_N)) * (Q_N_xx_avg + D_term_N);
    }
  }
}

void JetAnalysis::read_Q_calib()
{
  TH1::AddDirectory(kFALSE);

  auto file = std::unique_ptr<TFile>(TFile::Open(m_input_Q_calib.c_str()));

  // Check if the file was opened successfully.
  if (!file || file->IsZombie())
  {
    throw std::runtime_error(std::format("Could not open file '{}'", m_input_Q_calib));
  }

  auto* h_sEPD_Bad_Channels = dynamic_cast<TH1*>(file->Get("h_sEPD_Bad_Channels"));

  if (!h_sEPD_Bad_Channels)
  {
    throw std::runtime_error(std::format("Could not find histogram 'h_sEPD_Bad_Channels' in file '{}'", m_input_Q_calib));
  }

  std::cout << std::format("Bad sEPD Channels\n");
  std::map<std::string, int> ctr;
  // Load Bad Channels
  for (int channel = 0; channel < h_sEPD_Bad_Channels->GetNbinsX(); ++channel)
  {
    // sEPD Channel Status
    // 0: good
    // non-zero: bad

    int status = static_cast<int>(h_sEPD_Bad_Channels->GetBinContent(channel + 1));
    if (status)
    {
      std::string badType;
      if (status == 1)
      {
        badType = "Dead";
      }
      if (status == 2)
      {
        badType = "Hot";
      }
      if (status == 3)
      {
        badType = "Cold";
      }

      m_bad_channels.insert(channel);
      std::cout << std::format("Channel: {:3d}, Type: {}\n", channel, badType);

      ++ctr[badType];
    }
  }
  std::cout << std::format("Total Bad sEPD Channels: {}, Dead: {}, Hot: {}, Cold: {}\n", m_bad_channels.size(), ctr["Dead"], ctr["Hot"], ctr["Cold"]);
  std::cout << std::format("{:#<20}\n", "");

  load_correction_data(file.get());
}

void JetAnalysis::process_dead_channels()
{
  std::cout << "Processing... dead_channels" << std::endl;
  setGlobalTag(m_dbtag);

  std::string emcal_hotmap = getCalibration("CEMC_BadTowerMap", m_runnumber);

  std::cout << std::format("EMCal Bad Tower Map: {}\n", emcal_hotmap);

  std::unique_ptr<CDBTTree> cdbttree_hotMap = std::make_unique<CDBTTree>(emcal_hotmap);

  const std::string fieldname = "status";

  std::string title = std::format("EMCal Dead: Run {} ; Tower Index #phi; Tower Index #eta", m_runnumber);
  m_hists2D["h2EMCalBadTowersDead"] = std::make_unique<TH2F>("h2EMCalBadTowersDead", title.c_str(), myUtils::m_nphi, 0, myUtils::m_nphi, myUtils::m_neta, 0, myUtils::m_neta);

  auto* h2Dead = m_hists2D["h2EMCalBadTowersDead"].get();

  // bad tower map hist
  unsigned int nTowers = static_cast<unsigned int>(myUtils::m_nphi * myUtils::m_neta);

  // status counters
  std::map<std::string, int> ctr;

  for (unsigned int channel = 0; channel < nTowers; ++channel)
  {
    unsigned int key = TowerInfoDefs::encode_emcal(channel);
    unsigned int phi = TowerInfoDefs::getCaloTowerPhiBin(key);
    unsigned int eta = TowerInfoDefs::getCaloTowerEtaBin(key);

    int hotMap_val = cdbttree_hotMap->GetIntValue(static_cast<int>(key), fieldname);
    if (hotMap_val == 1)
    {
      h2Dead->Fill(phi, eta);
      ++ctr["dead"];
    }
  }

  std::cout << std::format("Dead Towers: {}\n", ctr["dead"]);

  m_hists2D["h2EMCalBadTowersDeadv2"] = std::unique_ptr<TH2>(static_cast<TH2*>(h2Dead->Clone("h2EMCalBadTowersDeadv2")));

  auto* h2Deadv2 = m_hists2D["h2EMCalBadTowersDeadv2"].get();
  h2Deadv2->Rebin2D(myUtils::m_ntowIBSide, myUtils::m_ntowIBSide);

  // half of the IB
  int ib_dead_tower_threshold = 32;

  for (int iphi = 1; iphi <= h2Deadv2->GetNbinsX(); ++iphi)
  {
    for (int ieta = 1; ieta <= h2Deadv2->GetNbinsY(); ++ieta)
    {
      int nDead = static_cast<int>(h2Deadv2->GetBinContent(iphi, ieta));

      if (nDead >= ib_dead_tower_threshold)
      {
        h2Deadv2->SetBinContent(iphi, ieta, 1);
      }
      else
      {
        h2Deadv2->SetBinContent(iphi, ieta, 0);
      }
    }
  }

  for (int iphi = 1; iphi <= h2Deadv2->GetNbinsX(); ++iphi)
  {
    for (int ieta = 1; ieta <= h2Deadv2->GetNbinsY(); ++ieta)
    {
      int status = static_cast<int>(h2Deadv2->GetBinContent(iphi, ieta));

      if (status == 1)
      {
        for (int dphi = -1; dphi <= 1; ++dphi)
        {
          for (int deta = -1; deta <= 1; ++deta)
          {
            if (dphi == 0 && deta == 0)
            {
              continue;
            }

            h2Deadv2->SetBinContent(iphi + dphi, ieta + deta, 2);
          }
        }
      }
    }
  }

  std::cout << "Finished... dead_channels" << std::endl;
}

void JetAnalysis::create_vn_histograms(int n)
{
  double sample_low = -0.5;
  double sample_high = m_bins_sample - 0.5;

  int bins_SP = 400;
  double SP_low = -1;
  double SP_high = 1;

  int bins_psi = 126;
  double psi_low = -std::numbers::pi;
  double psi_high = std::numbers::pi;

  // TH3 for Scalar Product
  std::string name = std::format("h3SP_re_{}", n);
  std::string title = std::format("Scalar Product (Order {}); Centrality [%]; Sample; SP", n);

  m_hists3D[name] = std::make_unique<TH3F>(name.c_str(), title.c_str(), m_bins_cent, m_cent_low, m_cent_high, m_bins_sample, sample_low, sample_high, bins_SP, SP_low, SP_high);

  std::string name_im = std::format("h3SP_im_{}", n);
  m_hists3D[name_im] = std::unique_ptr<TH3>(static_cast<TH3*>(m_hists3D[name]->Clone(name_im.c_str())));

  // TProfile2D for Scalar Product
  std::string name_re_prof = std::format("h2SP_re_prof_{}", n);
  std::string name_im_prof = std::format("h2SP_im_prof_{}", n);

  title = std::format("Scalar Product (Order {}); Centrality [%]; Sample", n);
  m_profiles2D[name_re_prof] = std::make_unique<TProfile2D>(name_re_prof.c_str(), title.c_str(), m_bins_cent, m_cent_low, m_cent_high, m_bins_sample, sample_low, sample_high);
  m_profiles2D[name_im_prof] = std::unique_ptr<TProfile2D>(static_cast<TProfile2D*>(m_profiles2D[name_re_prof]->Clone(name_im_prof.c_str())));

  // TProfile for Scalar Product
  for(auto pt : m_jet_pt_min_vec)
  {
    name_re_prof = std::format("hSP_re_prof_{}_{}", n, pt);

    title = std::format("Scalar Product; Centrality [%]; Re(#LTq_{{{0}}} Q^{{S|N*}}_{{{0}}}#GT)", n);
    m_profiles[name_re_prof] = std::make_unique<TProfile>(name_re_prof.c_str(), title.c_str(), m_bins_cent, m_cent_low, m_cent_high);

    name_re_prof = std::format("hSP_re_anti_prof_{}_{}", n, pt);

    title = std::format("Scalar Product; Centrality [%]; Re(#LTq_{{{0}}} Q^{{N|S*}}_{{{0}}}#GT)", n);
    m_profiles[name_re_prof] = std::make_unique<TProfile>(name_re_prof.c_str(), title.c_str(), m_bins_cent, m_cent_low, m_cent_high);
  }

  // TH3 for Reference Flow
  std::string name_res = std::format("h3SP_res_{}", n);
  title = std::format("sEPD (Order {0}): Q^{{S}}Q^{{N*}}; Centrality [%]; Sample; Re(Q^{{S}}_{{{0}}} Q^{{N*}}_{{{0}}}GT)", n);
  m_hists3D[name_res] = std::unique_ptr<TH3>(static_cast<TH3*>(m_hists3D[name]->Clone(name_res.c_str())));
  m_hists3D[name_res]->SetTitle(title.c_str());

  // TProfile2D for Reference Flow
  std::string name_res_prof = std::format("h2SP_res_prof_{}", n);
  title = std::format("sEPD: Re(#LT Q^{{S}}_{{{0}}} Q^{{N*}}_{{{0}}}#GT); Centrality [%]; Sample", n);
  m_profiles2D[name_res_prof] = std::make_unique<TProfile2D>(name_res_prof.c_str(), title.c_str(), m_bins_cent, m_cent_low, m_cent_high, m_bins_sample, sample_low, sample_high);

  // TProfile for Reference Flow
  name_res_prof = std::format("hSP_res_prof_{}", n);
  title = std::format("; Centrality [%]; Re(#LT Q^{{S}}_{{{0}}} Q^{{N*}}_{{{0}}}#GT)", n);
  m_profiles[name_res_prof] = std::make_unique<TProfile>(name_res_prof.c_str(), title.c_str(), m_bins_cent, m_cent_low, m_cent_high);

  std::string name_evt_res_prof = std::format("hSP_evt_res_prof_{}", n);
  title = std::format("; Centrality [%]; #LTRe(Q^{{S}}_{{{0}}} Q^{{N*}}_{{{0}}}) / (|Q^{{S}}_{{{0}}}||Q^{{N}}_{{{0}}}|)#GT", n);
  m_profiles[name_evt_res_prof] = std::make_unique<TProfile>(name_evt_res_prof.c_str(), title.c_str(), m_bins_cent, m_cent_low, m_cent_high);

  std::string psi_corr2_hist_name = std::format("h3_sEPD_Psi_{}_corr2", n);
  m_hists3D[psi_corr2_hist_name] = std::make_unique<TH3F>(psi_corr2_hist_name.c_str(),
                                                          std::format("sEPD #Psi (Order {0}): |z| < 10 cm and MB; {0}#Psi^{{S}}_{{{0}}}; {0}#Psi^{{N}}_{{{0}}}; Centrality [%]", n).c_str(),
                                                          bins_psi, psi_low, psi_high, bins_psi, psi_low, psi_high, m_bins_cent, m_cent_low, m_cent_high);

  // South, North
  for (auto det : m_subdetectors)
  {
    std::string det_str = (det == Subdetector::S) ? "S" : "N";
    std::string det_name = (det == Subdetector::S) ? "South" : "North";

    std::string q_avg_sq_cross_raw_name = std::format("h_sEPD_Q_{}_xy_{}_raw_avg", det_str, n);

    m_profiles[q_avg_sq_cross_raw_name] = std::make_unique<TProfile>(q_avg_sq_cross_raw_name.c_str(),
                                                                      std::format("sEPD {0}; Centrality [%]; <Q_{{{1},x}} Q_{{{1},y}}>", det_name, n).c_str(),
                                                                      m_bins_cent, m_cent_low, m_cent_high);

    std::string q_avg_sq_cross_corr_name = std::format("h_sEPD_Q_{}_xy_{}_corr_avg", det_str, n);

    m_profiles[q_avg_sq_cross_corr_name] = std::make_unique<TProfile>(q_avg_sq_cross_corr_name.c_str(),
                                                                      std::format("sEPD {0}; Centrality [%]; <Q_{{{1},x}} Q_{{{1},y}}>", det_name, n).c_str(),
                                                                      m_bins_cent, m_cent_low, m_cent_high);
    // X, Y
    for (auto comp : m_components)
    {
      std::string comp_str = (comp == QComponent::X) ? "x" : "y";
      std::string q_avg_raw_name = std::format("h_sEPD_Q_{}_{}_{}_raw_avg", det_str, comp_str, n);
      std::string q_avg_corr_name = std::format("h_sEPD_Q_{}_{}_{}_corr_avg", det_str, comp_str, n);
      std::string q_avg_sq_raw_name = std::format("h_sEPD_Q_{0}_{1}{1}_{2}_raw_avg", det_str, comp_str, n);
      std::string q_avg_sq_corr_name = std::format("h_sEPD_Q_{0}_{1}{1}_{2}_corr_avg", det_str, comp_str, n);

      m_profiles[q_avg_raw_name] = std::make_unique<TProfile>(q_avg_raw_name.c_str(),
                                                              std::format("sEPD {}; Centrality [%]; <Q_{{{},{}}}>", det_name, n, comp_str).c_str(),
                                                              m_bins_cent, m_cent_low, m_cent_high);

      m_profiles[q_avg_corr_name] = std::make_unique<TProfile>(q_avg_corr_name.c_str(),
                                                               std::format("sEPD {}; Centrality [%]; <Q_{{{},{}}}>", det_name, n, comp_str).c_str(),
                                                               m_bins_cent, m_cent_low, m_cent_high);

      m_profiles[q_avg_sq_raw_name] = std::make_unique<TProfile>(q_avg_sq_raw_name.c_str(),
                                                                  std::format("sEPD {}; Centrality [%]; <Q_{{{},{}}}^{{2}}>", det_name, n, comp_str).c_str(),
                                                                  m_bins_cent, m_cent_low, m_cent_high);

      m_profiles[q_avg_sq_corr_name] = std::make_unique<TProfile>(q_avg_sq_corr_name.c_str(),
                                                                  std::format("sEPD {}; Centrality [%]; <Q_{{{},{}}}^{{2}}>", det_name, n, comp_str).c_str(),
                                                                  m_bins_cent, m_cent_low, m_cent_high);
    }
  }
}

void JetAnalysis::init_hists()
{
  int bins_phi = 64;
  double phi_low = 0;
  double phi_high = 2 * std::numbers::pi;

  int bins_eta = 24;
  double eta_low = -1.152;
  double eta_high = 1.152;

  int bins_pt = 50;
  double pt_low = 0;
  double pt_high = 50;

  double sample_low = -0.5;
  double sample_high = m_bins_sample - 0.5;

  m_hists3D["h3JetPhiEtaPt"] = std::make_unique<TH3F>("h3JetPhiEtaPt", "Jet: |z| < 10 cm and MB; #phi; #eta; p_{T} [GeV]"
                                                      , bins_phi, phi_low, phi_high
                                                      , bins_eta, eta_low, eta_high
                                                      , bins_pt, pt_low, pt_high);
  m_hists3D["h3JetPhiEtaPtv2"] = std::unique_ptr<TH3>(static_cast<TH3*>(m_hists3D["h3JetPhiEtaPt"]->Clone("h3JetPhiEtaPtv2")));

  m_hists2D["h2Event"] = std::make_unique<TH2F>("h2Event", "Events: |z| < 10 and MB; Centrality [%]; Sample"
                                                , m_bins_cent, m_cent_low, m_cent_high, m_bins_sample, sample_low, sample_high);
  m_hists2D["h2Jet"] = std::make_unique<TH2F>("h2Jet", "Jets; Centrality [%]; Sample"
                                              , m_bins_cent, m_cent_low, m_cent_high, m_bins_sample, sample_low, sample_high);

  m_hists1D["hCentrality"] = std::make_unique<TH1F>("hCentrality", "Centrality: |z| < 10 cm and MB; Centrality [%]; Events"
                                                    , m_bins_cent, m_cent_low, m_cent_high);

  for (auto n : m_harmonics)
  {
    create_vn_histograms(n);
  }

  m_hists2D["h2Dummy"] = std::unique_ptr<TH2>(static_cast<TH2*>(m_hists3D["h3JetPhiEtaPt"]->Project3D("yx")->Clone("h2Dummy")));
  m_hists2D["h2Dummy"]->Rebin2D(2, 2);

  m_hists.h2Dummy = m_hists2D["h2Dummy"].get();
  m_hists.h2EMCalBadTowersDeadv2 = m_hists2D["h2EMCalBadTowersDeadv2"].get();
  m_hists.h3JetPhiEtaPt = m_hists3D["h3JetPhiEtaPt"].get();
  m_hists.h3JetPhiEtaPtv2 = m_hists3D["h3JetPhiEtaPtv2"].get();
  m_hists.h2Event = m_hists2D["h2Event"].get();
  m_hists.h2Jet = m_hists2D["h2Jet"].get();
  m_hists.hCentrality = m_hists1D["hCentrality"].get();

  for (size_t n_idx = 0; n_idx < m_harmonics.size(); ++n_idx)
  {
    int n = m_harmonics[n_idx];
    m_hists.hPsi[n_idx] = m_hists3D[std::format("h3_sEPD_Psi_{}_corr2", n)].get();
    m_hists.h3SP_re[n_idx] = m_hists3D[std::format("h3SP_re_{}", n)].get();
    m_hists.h3SP_im[n_idx] = m_hists3D[std::format("h3SP_im_{}", n)].get();
    m_hists.h3SP_res[n_idx] = m_hists3D[std::format("h3SP_res_{}", n)].get();
    m_hists.p2SP_re[n_idx] = m_profiles2D[std::format("h2SP_re_prof_{}", n)].get();
    m_hists.p2SP_im[n_idx] = m_profiles2D[std::format("h2SP_im_prof_{}", n)].get();
    m_hists.p2SP_res[n_idx] = m_profiles2D[std::format("h2SP_res_prof_{}", n)].get();
    m_hists.p1SP_res[n_idx] = m_profiles[std::format("hSP_res_prof_{}", n)].get();
    m_hists.p1SP_evt_res[n_idx] = m_profiles[std::format("hSP_evt_res_prof_{}", n)].get();

    m_hists.S_x_raw_avg[n_idx] = m_profiles[std::format("h_sEPD_Q_S_x_{}_raw_avg", n)].get();
    m_hists.S_y_raw_avg[n_idx] = m_profiles[std::format("h_sEPD_Q_S_y_{}_raw_avg", n)].get();
    m_hists.N_x_raw_avg[n_idx] = m_profiles[std::format("h_sEPD_Q_N_x_{}_raw_avg", n)].get();
    m_hists.N_y_raw_avg[n_idx] = m_profiles[std::format("h_sEPD_Q_N_y_{}_raw_avg", n)].get();

    m_hists.S_x_corr_avg[n_idx] = m_profiles[std::format("h_sEPD_Q_S_x_{}_corr_avg", n)].get();
    m_hists.S_y_corr_avg[n_idx] = m_profiles[std::format("h_sEPD_Q_S_y_{}_corr_avg", n)].get();
    m_hists.N_x_corr_avg[n_idx] = m_profiles[std::format("h_sEPD_Q_N_x_{}_corr_avg", n)].get();
    m_hists.N_y_corr_avg[n_idx] = m_profiles[std::format("h_sEPD_Q_N_y_{}_corr_avg", n)].get();

    m_hists.S_xx_raw_avg[n_idx] = m_profiles[std::format("h_sEPD_Q_S_xx_{}_raw_avg", n)].get();
    m_hists.S_yy_raw_avg[n_idx] = m_profiles[std::format("h_sEPD_Q_S_yy_{}_raw_avg", n)].get();
    m_hists.S_xy_raw_avg[n_idx] = m_profiles[std::format("h_sEPD_Q_S_xy_{}_raw_avg", n)].get();

    m_hists.N_xx_raw_avg[n_idx] = m_profiles[std::format("h_sEPD_Q_N_xx_{}_raw_avg", n)].get();
    m_hists.N_yy_raw_avg[n_idx] = m_profiles[std::format("h_sEPD_Q_N_yy_{}_raw_avg", n)].get();
    m_hists.N_xy_raw_avg[n_idx] = m_profiles[std::format("h_sEPD_Q_N_xy_{}_raw_avg", n)].get();

    m_hists.S_xx_corr_avg[n_idx] = m_profiles[std::format("h_sEPD_Q_S_xx_{}_corr_avg", n)].get();
    m_hists.S_yy_corr_avg[n_idx] = m_profiles[std::format("h_sEPD_Q_S_yy_{}_corr_avg", n)].get();
    m_hists.S_xy_corr_avg[n_idx] = m_profiles[std::format("h_sEPD_Q_S_xy_{}_corr_avg", n)].get();

    m_hists.N_xx_corr_avg[n_idx] = m_profiles[std::format("h_sEPD_Q_N_xx_{}_corr_avg", n)].get();
    m_hists.N_yy_corr_avg[n_idx] = m_profiles[std::format("h_sEPD_Q_N_yy_{}_corr_avg", n)].get();
    m_hists.N_xy_corr_avg[n_idx] = m_profiles[std::format("h_sEPD_Q_N_xy_{}_corr_avg", n)].get();

    for(size_t idx_pt = 0; idx_pt < m_jet_pt_min_vec.size(); ++idx_pt)
    {
      int pt = m_jet_pt_min_vec[idx_pt];
      m_hists.p1SP_re[n_idx][idx_pt] = m_profiles[std::format("hSP_re_prof_{}_{}", n, pt)].get();
      m_hists.p1SP_re_anti[n_idx][idx_pt] = m_profiles[std::format("hSP_re_anti_prof_{}_{}", n, pt)].get();
    }
  }
}

void JetAnalysis::correct_QVecs()
{
  double cent = m_event_data.event_centrality;
  size_t cent_bin = static_cast<size_t>(m_hists.hCentrality->FindBin(cent) - 1);

  size_t south_idx = static_cast<size_t>(Subdetector::S);
  size_t north_idx = static_cast<size_t>(Subdetector::N);

  for (size_t n_idx = 0; n_idx < m_harmonics.size(); ++n_idx)
  {
    double Q_S_x_avg = m_correction_data[cent_bin][n_idx][south_idx].avg_Q.x;
    double Q_S_y_avg = m_correction_data[cent_bin][n_idx][south_idx].avg_Q.y;
    double Q_N_x_avg = m_correction_data[cent_bin][n_idx][north_idx].avg_Q.x;
    double Q_N_y_avg = m_correction_data[cent_bin][n_idx][north_idx].avg_Q.y;

    QVec q_S = m_event_data.q_vectors[n_idx][south_idx];
    QVec q_N = m_event_data.q_vectors[n_idx][north_idx];

    // Apply Recentering
    QVec q_S_corr = {q_S.x - Q_S_x_avg, q_S.y - Q_S_y_avg};
    QVec q_N_corr = {q_N.x - Q_N_x_avg, q_N.y - Q_N_y_avg};

    const auto& X_S = m_correction_data[cent_bin][n_idx][south_idx].X_matrix;
    const auto& X_N = m_correction_data[cent_bin][n_idx][north_idx].X_matrix;

    // Apply Flattening
    double Q_S_x_corr2 = X_S[0][0] * q_S_corr.x + X_S[0][1] * q_S_corr.y;
    double Q_S_y_corr2 = X_S[1][0] * q_S_corr.x + X_S[1][1] * q_S_corr.y;
    double Q_N_x_corr2 = X_N[0][0] * q_N_corr.x + X_N[0][1] * q_N_corr.y;
    double Q_N_y_corr2 = X_N[1][0] * q_N_corr.x + X_N[1][1] * q_N_corr.y;

    QVec q_S_corr2 = {Q_S_x_corr2, Q_S_y_corr2};
    QVec q_N_corr2 = {Q_N_x_corr2, Q_N_y_corr2};

    m_event_data.q_vectors[n_idx][south_idx] = q_S_corr2;
    m_event_data.q_vectors[n_idx][north_idx] = q_N_corr2;

    double psi_S = std::atan2(q_S_corr2.y, q_S_corr2.x);
    double psi_N = std::atan2(q_N_corr2.y, q_N_corr2.x);

    m_hists.hPsi[n_idx]->Fill(psi_S, psi_N, cent);

    m_hists.S_x_raw_avg[n_idx]->Fill(cent, q_S.x);
    m_hists.S_y_raw_avg[n_idx]->Fill(cent, q_S.y);
    m_hists.N_x_raw_avg[n_idx]->Fill(cent, q_N.x);
    m_hists.N_y_raw_avg[n_idx]->Fill(cent, q_N.y);

    m_hists.S_x_corr_avg[n_idx]->Fill(cent, q_S_corr2.x);
    m_hists.S_y_corr_avg[n_idx]->Fill(cent, q_S_corr2.y);
    m_hists.N_x_corr_avg[n_idx]->Fill(cent, q_N_corr2.x);
    m_hists.N_y_corr_avg[n_idx]->Fill(cent, q_N_corr2.y);

    m_hists.S_xx_raw_avg[n_idx]->Fill(cent, q_S.x * q_S.x);
    m_hists.S_yy_raw_avg[n_idx]->Fill(cent, q_S.y * q_S.y);
    m_hists.S_xy_raw_avg[n_idx]->Fill(cent, q_S.x * q_S.y);

    m_hists.N_xx_raw_avg[n_idx]->Fill(cent, q_N.x * q_N.x);
    m_hists.N_yy_raw_avg[n_idx]->Fill(cent, q_N.y * q_N.y);
    m_hists.N_xy_raw_avg[n_idx]->Fill(cent, q_N.x * q_N.y);

    m_hists.S_xx_corr_avg[n_idx]->Fill(cent, q_S_corr2.x * q_S_corr2.x);
    m_hists.S_yy_corr_avg[n_idx]->Fill(cent, q_S_corr2.y * q_S_corr2.y);
    m_hists.S_xy_corr_avg[n_idx]->Fill(cent, q_S_corr2.x * q_S_corr2.y);

    m_hists.N_xx_corr_avg[n_idx]->Fill(cent, q_N_corr2.x * q_N_corr2.x);
    m_hists.N_yy_corr_avg[n_idx]->Fill(cent, q_N_corr2.y * q_N_corr2.y);
    m_hists.N_xy_corr_avg[n_idx]->Fill(cent, q_N_corr2.x * q_N_corr2.y);
  }
}

bool JetAnalysis::compute_QVecs()
{
  size_t nChannels = m_event_data.sepd_channel->size();

  double sepd_total_charge_south = 0;
  double sepd_total_charge_north = 0;

  // Loop over all sEPD Channels
  for (size_t idx = 0; idx < nChannels; ++idx)
  {
    int channel = m_event_data.sepd_channel->at(idx);
    double charge = m_event_data.sepd_charge->at(idx);
    double phi = m_event_data.sepd_phi->at(idx);

    // Skip Bad Channels
    if (m_bad_channels.contains(channel))
    {
      continue;
    }

    unsigned int key = TowerInfoDefs::encode_epd(static_cast<unsigned int>(channel));
    unsigned int arm = TowerInfoDefs::get_epd_arm(key);
    int rbin = static_cast<int>(TowerInfoDefs::get_epd_rbin(key));

    if (!myUtils::filter_sEPD(rbin, m_QVecAna))
    {
      m_rbins_skipped.insert(rbin);
      continue;
    }

    // arm = 0: South
    // arm = 1: North
    double& sepd_total_charge = (arm == 0) ? sepd_total_charge_south : sepd_total_charge_north;

    // Compute total charge for the respective sEPD arm
    sepd_total_charge += charge;

    // Compute Raw Q vectors for each harmonic and respective arm
    for (size_t n_idx = 0; n_idx < m_harmonics.size(); ++n_idx)
    {
      int n = m_harmonics[n_idx];
      m_event_data.q_vectors[n_idx][arm].x += charge * std::cos(n * phi);
      m_event_data.q_vectors[n_idx][arm].y += charge * std::sin(n * phi);
    }
  }

  // Skip Events with Zero sEPD Total Charge in either arm
  if (sepd_total_charge_south == 0 || sepd_total_charge_north == 0)
  {
    std::cout << std::format("Warning! Q-Vec Zero: Event {}\n", m_event_data.event_id);
    return false;
  }

  // Normalize the Q-vectors by total charge
  for (size_t n_idx = 0; n_idx < m_harmonics.size(); ++n_idx)
  {
    for (auto det : m_subdetectors)
    {
      size_t arm = static_cast<size_t>(det);
      double sepd_total_charge = (arm == 0) ? sepd_total_charge_south : sepd_total_charge_north;
      m_event_data.q_vectors[n_idx][arm].x /= sepd_total_charge;
      m_event_data.q_vectors[n_idx][arm].y /= sepd_total_charge;
    }
  }

  return true;
}

void JetAnalysis::compute_SP_resolution(int sample)
{
  double cent = m_event_data.event_centrality;
  m_hists.h2Event->Fill(cent, sample);

  size_t south_idx = static_cast<size_t>(Subdetector::S);
  size_t north_idx = static_cast<size_t>(Subdetector::N);

  // Compute Scalar Product for each harmonic
  for (size_t n_idx = 0; n_idx < m_harmonics.size(); ++n_idx)
  {
    QVec sEPD_Q_S = m_event_data.q_vectors[n_idx][south_idx];
    QVec sEPD_Q_N = m_event_data.q_vectors[n_idx][north_idx];

    double SP_res = sEPD_Q_S.x * sEPD_Q_N.x + sEPD_Q_S.y * sEPD_Q_N.y;
    double norm_S = std::sqrt(sEPD_Q_S.x*sEPD_Q_S.x + sEPD_Q_S.y*sEPD_Q_S.y);
    double norm_N = std::sqrt(sEPD_Q_N.x*sEPD_Q_N.x + sEPD_Q_N.y*sEPD_Q_N.y);
    double SP_evt_res = SP_res / (norm_S * norm_N);

    m_hists.h3SP_res[n_idx]->Fill(cent, sample, SP_res);
    m_hists.p2SP_res[n_idx]->Fill(cent, sample, SP_res);
    m_hists.p1SP_res[n_idx]->Fill(cent, SP_res);
    m_hists.p1SP_evt_res[n_idx]->Fill(cent, SP_evt_res);
  }
}

void JetAnalysis::compute_SP(int sample)
{
  std::vector<JetInfo> jet_info = process_jets();
    
  size_t nJets = jet_info.size();
  double cent = m_event_data.event_centrality;

  m_hists.h2Jet->Fill(cent, sample, static_cast<int>(nJets));

  // Loop over all jets
  for (size_t idx = 0; idx < nJets; ++idx)
  {
    double phi = jet_info[idx].phi;
    double eta = jet_info[idx].eta;
    double pt = jet_info[idx].pt;

    size_t arm = (eta < 0) ? static_cast<size_t>(Subdetector::N) : static_cast<size_t>(Subdetector::S);
    size_t arm_anti = (eta > 0) ? static_cast<size_t>(Subdetector::N) : static_cast<size_t>(Subdetector::S);

    // Compute Scalar Product for each harmonic
    for (size_t n_idx = 0; n_idx < m_harmonics.size(); ++n_idx)
    {
      int n = m_harmonics[n_idx];
      QVec jet_Q = {std::cos(n * phi), std::sin(n * phi)};
      QVec sEPD_Q = m_event_data.q_vectors[n_idx][arm];
      QVec sEPD_Q_anti = m_event_data.q_vectors[n_idx][arm_anti];

      double SP_re = jet_Q.x * sEPD_Q.x + jet_Q.y * sEPD_Q.y;
      double SP_re_anti = jet_Q.x * sEPD_Q_anti.x + jet_Q.y * sEPD_Q_anti.y;
      double SP_im = jet_Q.y * sEPD_Q.x - jet_Q.x * sEPD_Q.y;

      m_hists.h3SP_re[n_idx]->Fill(cent, sample, SP_re);
      m_hists.h3SP_im[n_idx]->Fill(cent, sample, SP_im);

      m_hists.p2SP_re[n_idx]->Fill(cent, sample, SP_re);
      m_hists.p2SP_im[n_idx]->Fill(cent, sample, SP_im);

      // Loop over each jet pT min
      for (size_t idx_pt = 0; idx_pt < m_jet_pt_min_vec.size(); ++idx_pt)
      {
        int pt_min = m_jet_pt_min_vec[idx_pt];

        // Ensure the jet has minimum pT before proceeding
        if (pt < pt_min)
        {
          break;
        }

        m_hists.p1SP_re[n_idx][idx_pt]->Fill(cent, SP_re);
        m_hists.p1SP_re_anti[n_idx][idx_pt]->Fill(cent, SP_re_anti);
      }
    }
  }
}

std::vector<JetAnalysis::JetInfo> JetAnalysis::process_jets()
{
  size_t nJets = m_event_data.jet_phi->size();

  std::vector<JetInfo> jet_info;
  jet_info.reserve(nJets);

  // Loop over all jets
  for (size_t idx = 0; idx < nJets; ++idx)
  {
    double pt = m_event_data.jet_pt->at(idx);
    double phi = m_event_data.jet_phi->at(idx);
    double eta = m_event_data.jet_eta->at(idx);

    if (pt < m_jet_pt_min || std::fabs(eta) >= m_jet_eta_max)
    {
      continue;
    }

    // map [-pi,pi] -> [0,2pi]
    if (phi < 0)
    {
      phi += 2.0 * std::numbers::pi;
    }

    int bin_phi = m_hists.h2Dummy->GetXaxis()->FindBin(phi);
    int bin_eta = m_hists.h2Dummy->GetYaxis()->FindBin(eta);
    int dead_status = static_cast<int>(m_hists.h2EMCalBadTowersDeadv2->GetBinContent(bin_phi, bin_eta));

    m_hists.h3JetPhiEtaPt->Fill(phi, eta, pt);

    if (dead_status == 0)
    {
      m_hists.h3JetPhiEtaPtv2->Fill(phi, eta, pt);
      jet_info.emplace_back(pt, phi, eta);
    }
  }

  return jet_info;
}

bool JetAnalysis::process_QVecs()
{
  bool isGood = compute_QVecs();
  correct_QVecs();

  return isGood;
}

void JetAnalysis::process_events()
{
  std::cout << "Processing... process_events" << std::endl;
  long long n_entries = m_chain->GetEntries();
  if (m_events_to_process)
  {
    n_entries = std::min(m_events_to_process, n_entries);
  }

  // Generate Sample Offset
  std::random_device rd;
  std::mt19937 generator(rd());
  std::uniform_int_distribution<> distribution(0, m_bins_sample - 1);
  int sample_offset = distribution(generator);
  std::cout << std::format("Sample Offset: {}\n", sample_offset);

  std::map<std::string, int> ctr;

  // Event Loop
  for (long long event = 0; event < n_entries; ++event)
  {
    // Load Event Data from TChain
    m_chain->GetEntry(event);
    // Reset Q-Vectors for the new event
    m_event_data.reset();

    if (event % 5000 == 0)
    {
      std::cout << std::format("Processing {}/{}: {:.2f} %", event, n_entries, static_cast<double>(event) * 100. / static_cast<double>(n_entries)) << std::endl;
    }

    double cent = m_event_data.event_centrality;
    int cent_bin = m_hists.hCentrality->FindBin(cent);

    // Skip events in underflow or overflow bins.
    if (cent_bin <= 0 || cent_bin > static_cast<int>(m_bins_cent))
    {
      std::cout << std::format("Warning: Weird Centrality: {}, Skipping Event\n", cent);
      ++ctr["events_skipped_cent"];
      continue;
    }

    // compute and correct the sEPD Q vectors
    bool isGood = process_QVecs();
    if (!isGood)
    {
      ++ctr["events_skipped_bad_Q_vec"];
      continue;
    }

    int events_cent = static_cast<int>(m_hists.hCentrality->GetBinContent(cent_bin));
    int sample = (events_cent + sample_offset) % m_bins_sample;
    m_hists.hCentrality->Fill(cent);

    // Scalar Product Method
    compute_SP(sample);

    // Scalar Product Resolution
    compute_SP_resolution(sample);
  }

  int jets = static_cast<int>(m_hists.h3JetPhiEtaPt->GetEntries());
  int jets_good = static_cast<int>(m_hists.h3JetPhiEtaPtv2->GetEntries());

  std::cout << std::format("Event Skipped: Cent (Out of Bounds): {}, Bad Q Vecs: {}\n", ctr["events_skipped_cent"], ctr["events_skipped_bad_Q_vec"]);
  std::cout << std::format("Jets: {}, Post Masking: {}, {:.2f} %\n", jets, jets_good, jets_good * 100. / jets);
  std::cout << std::format("QVecAna: {}, rbins skipped: {}\n", static_cast<int>(m_QVecAna), m_rbins_skipped.size());

  std::cout << "Finished... process_events" << std::endl;
}

void JetAnalysis::save_results() const
{
  std::filesystem::create_directories(m_output_dir);

  std::filesystem::path input_path(m_input_file);
  std::string output_stem = input_path.stem().string();
  std::string output_filename = std::format("{}/Jet-Ana_{}.root", m_output_dir, output_stem);

  auto output_file = std::make_unique<TFile>(output_filename.c_str(), "RECREATE");

  for (const auto& [name, hist] : m_hists1D)
  {
    std::cout << std::format("Saving: {}\n", name);
    hist->Write();
  }
  for (const auto& [name, hist] : m_hists2D)
  {
    std::cout << std::format("Saving: {}\n", name);
    hist->Write();
  }
  for (const auto& [name, hist] : m_hists3D)
  {
    std::cout << std::format("Saving: {}\n", name);
    hist->Write();
  }
  for (const auto& [name, hist] : m_profiles)
  {
    std::cout << std::format("Saving: {}\n", name);
    hist->Write();
  }
  for (const auto& [name, hist] : m_profiles2D)
  {
    std::cout << std::format("Saving: {}\n", name);
    hist->Write();
  }

  // Save Projections for Convenience
  auto project_and_write = [&](const std::string& hist_name, const std::string& projection)
  {
    auto* hist = m_hists3D.at(hist_name).get();
    hist->Project3D(projection.c_str())->Write();
  };

  project_and_write("h3JetPhiEtaPt", "z");
  project_and_write("h3JetPhiEtaPt", "yx");
  project_and_write("h3JetPhiEtaPtv2", "z");
  project_and_write("h3JetPhiEtaPtv2", "yx");

  output_file->Close();

  std::cout << std::format("Results saved to: {}", output_filename) << std::endl;
}

// ====================================================================
// Main function remains clean and simple
// ====================================================================
int main(int argc, const char* const argv[])
{
  gROOT->SetBatch(true);

  if (argc < 4 || argc > 9)
  {
    std::cout << "Usage: " << argv[0] << " input_file <input_SEPD_Q_vec_calib> <runnumber> [QVecAna] [events] [jet_pt_min] [jet_eta_max] [output_directory]" << std::endl;
    return 1;
  }

  const std::string input_file = argv[1];
  const std::string input_Q_calib = argv[2];
  unsigned int runnumber = static_cast<unsigned int>(std::atoi(argv[3]));
  const std::string q_vec_ana_str = (argc >= 5) ? argv[4] : "DEFAULT"; // Default to the first pass
  long long events = (argc >= 6) ? std::atoll(argv[5]) : 0;
  double jet_pt_min = (argc >= 7) ? std::stod(argv[6]) : 7;
  double jet_eta_max = (argc >= 8) ? std::stod(argv[7]) : 0.9;
  std::string output_dir = (argc >= 9) ? argv[8] : ".";

  myUtils::QVecAna q_vec_ana = myUtils::QVecAna::DEFAULT;
  if (myUtils::q_vec_ana_map.contains(q_vec_ana_str))
  {
    q_vec_ana = myUtils::q_vec_ana_map.at(q_vec_ana_str);
  }
  else
  {
    std::cout << std::format("Error: Invalid q_vec_ana specified: {}\n", q_vec_ana_str);
    std::cout << "Available q_vec_ana are: DEFAULT, HALF, HALF1" << std::endl;
    return 1;
  }

  std::cout << std::format("{:#<20}\n", "");
  std::cout << std::format("Run Params\n");
  std::cout << std::format("Input: {}\n", input_file);
  std::cout << std::format("Q-vec-calib: {}\n", input_Q_calib);
  std::cout << std::format("Run Number: {}\n", runnumber);
  std::cout << std::format("Q-vec Ana: {}\n", q_vec_ana_str);
  std::cout << std::format("Events: {}\n", events);
  std::cout << std::format("Jet pT min: {} [GeV]\n", jet_pt_min);
  std::cout << std::format("Jet eta max: {}\n", jet_eta_max);
  std::cout << std::format("{:#<20}\n", "");

  try
  {
    JetAnalysis analysis(input_file, input_Q_calib, runnumber, static_cast<int>(q_vec_ana), events, output_dir);
    analysis.set_jet_pt_min(jet_pt_min);
    analysis.set_jet_eta_max(jet_eta_max);
    analysis.run();
  }
  catch (const std::exception& e)
  {
    std::cout << std::format("An exception occurred: {}", e.what()) << std::endl;
    return 1;
  }

  std::cout << "Analysis complete." << std::endl;
  return 0;
}
